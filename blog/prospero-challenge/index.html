<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        
        <title>Solving the Prospero challenge | refice.dev</title>
        <meta name="description" content="How I wrote a small JIT compiler from scratch, in Rust." />
        

        <meta name="author" content="Carlo Refice" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <link rel="stylesheet" type="text/css" href=https://www.refice.dev/style.css />
    </head>

    <body>
        <header>
    <nav>
        <ul>
            <li class="site-logo">refice.dev</li>
            <li><a href="/">Home</a></li>
            <li><a href="/blog">Blog</a></li>
            <li><a href="https://github.com/CRefice/resume/releases/download/master/resume.pdf">Resume</a></li>
        </ul>
    </nav>
</header>

        <main>
            
<header class="post-header">
    <h1><a href=https:&#x2F;&#x2F;www.refice.dev&#x2F;blog&#x2F;prospero-challenge&#x2F;>Solving the Prospero challenge</a></h1>
    <p class="subheader">
    April 25, 2025 —
    32 min read
    </p>
    
        <p>How I wrote a small JIT compiler from scratch, in Rust.</p>
    

    
    <section class="toc">
        <h1>Contents</h2>
        <ul>
            
            <li>
                <a href="https://www.refice.dev/blog/prospero-challenge/#the-challenge">The challenge</a>
                
            </li>
            
            <li>
                <a href="https://www.refice.dev/blog/prospero-challenge/#my-approach-writing-a-compiler">My approach: writing a compiler</a>
                
            </li>
            
            <li>
                <a href="https://www.refice.dev/blog/prospero-challenge/#instruction-representation">Instruction representation</a>
                
            </li>
            
            <li>
                <a href="https://www.refice.dev/blog/prospero-challenge/#emitting-cpu-instructions">Emitting CPU instructions</a>
                
            </li>
            
            <li>
                <a href="https://www.refice.dev/blog/prospero-challenge/#register-allocation">Register allocation</a>
                
            </li>
            
            <li>
                <a href="https://www.refice.dev/blog/prospero-challenge/#running-the-code">Running the code</a>
                
            </li>
            
            <li>
                <a href="https://www.refice.dev/blog/prospero-challenge/#debugging">Debugging</a>
                
            </li>
            
            <li>
                <a href="https://www.refice.dev/blog/prospero-challenge/#intermediate-results">Intermediate results</a>
                
            </li>
            
            <li>
                <a href="https://www.refice.dev/blog/prospero-challenge/#optimization">Optimization</a>
                
            </li>
            
            <li>
                <a href="https://www.refice.dev/blog/prospero-challenge/#multithreading-and-borrow-checker-issues">Multithreading and borrow checker issues</a>
                
            </li>
            
            <li>
                <a href="https://www.refice.dev/blog/prospero-challenge/#final-results">Final results</a>
                
            </li>
            
            <li>
                <a href="https://www.refice.dev/blog/prospero-challenge/#conclusion">Conclusion</a>
                
            </li>
            
        </ul>
    </section>
    
</header>

<p>Performance optimization challenges are extremely compelling to me. You have a well defined problem with a deceptively simple solution, and your job is to use any tricks you can to make it run as quickly as possible. You start from a high level idea of how to architect your solution to be performant, and before long you're looking at assembly code and processor performance counters to squeeze the last few drops of performance you can. It's all very engaging.</p>
<p>A few weeks ago a colleague shared Matt Keeter's <a href="https://www.mattkeeter.com/projects/prospero/">Prospero Challenge</a> on the office Slack channel, and I immediately knew it would be up my alley.</p>
<p>I've enjoyed hacking away at it even more than I thought I would, so much so that I decided to not just put my solution up on GitHub, but to walk through it step by step in this blog post.</p>
<p>(Hence why this is pretty late compared to when the challenge was posted. Whoops.)</p>
<span id="continue-reading"></span><h2 id="the-challenge">The challenge</h2>
<p>You are given a linear stream of instructions for a simple virtual machine
with only a handful of operations and no control flow. All intermediate values are floating-point numbers.</p>
<pre style="background-color:#eff1f5;color:#4f5b66;"><code><span># Text of a monologue from The Tempest
</span><span>_0 const 2.95
</span><span>_1 var-x
</span><span>_2 const 8.13008
</span><span>_3 mul _1 _2
</span><span>_4 add _0 _3
</span><span>_5 const 3.675
</span><span>_6 add _5 _3
</span><span>_7 neg _6
</span><span>_8 max _4 _7
</span><span>[... another 7000 or so more instructions ...]
</span><span>_1eb5 sub _1eb3 _15
</span><span>_1eb6 max _1eb4 _1eb5
</span><span>_1eb7 min _1eaf _1eb6
</span><span>_1eb8 max _1ea9 _1eb7
</span><span>_1eb9 min _1ea3 _1eb8
</span></code></pre>
<p>This "program" is really just a single function, which accepts two parameters (<code>var-x</code> and <code>var-y</code>) and whose return value is the last instruction in the stream.
What this function represents is a 2D implicit surface over the <code>[-1, +1]</code> square, with the X and Y positions bound to the <code>var-x</code> and <code>var-y</code> parameters.</p>
<p>By evaluating this surface on a square grid of pixels, then thresholding the result so that only pixels with a value &lt; 0.0 are white, you should get the following image:</p>
<p><img src="https://www.refice.dev/blog/prospero-challenge/prospero.png" alt="Text image of a passage from Shakespeare&#39;s The Tempest, Act 5, Scene 1" /></p>
<p>Of course, the higher the resolution you render the image at, the longer it will take.</p>
<p>The goal of the challenge is to optimize the evaluation of this function so it renders as fast as possible.
The only constraint is no pre-computation: the solution should work with any instruction stream, not just the example one given in the challenge.
Other than that, anything goes!</p>
<h2 id="my-approach-writing-a-compiler">My approach: writing a compiler</h2>
<p>The fact that the same stream of instructions is run for each pixel in the image immediately stuck out to me.</p>
<p>This is the perfect use case for <em>compiling</em> the VM instructions into actual machine code that our processor can run directly.
We'd have to do this at runtime (remember, we can't pre-compute the instruction stream) and this would incur some overhead.
But, that overhead is fixed and occurs only once, whereas the VM instructions can be run up to millions of times at higher resolutions!
It stands to reason then that spending some time making the VM instructions as fast as possible would be well worth it, and beat even the most optimized of interpreters.</p>
<p>To really get the most bang for our buck in terms of performance, we can generate <a href="https://en.wikipedia.org/wiki/Single_instruction,_multiple_data">SIMD</a> instructions that will evaluate multiple pixels at once, cutting our execution time down to a fraction of what it would be with serial instructions.</p>
<p>Now, we could (and a production-ready implementation probably <em>should</em>) use a ready-made compiler framework
like <a href="https://llvm.org/">LLVM</a> or <a href="https://cranelift.dev/">Cranelift</a> as our compiler back-end.
But for this challenge, I instead opted for a bespoke solution, for a few reasons:</p>
<ul>
<li>LLVM generates very optimized code, but is very slow at doing so. <a href="https://github.com/yolhan83/ProsperoChal">Other challenge submissions</a> that use LLVM have reported compilation taking up to 15 seconds.
That would completely obliterate any time savings that could possibly be achieved by more efficient code.</li>
<li>The instruction stream is already in <a href="https://en.wikipedia.org/wiki/Static_single-assignment_form">SSA form</a>,
and instructions are already sorted such that an instruction always comes after its inputs.
Therefore, there's no need for complex instruction transformations: we can simply do a linear scan over the instruction stream and convert it to machine code directly.</li>
<li>I just wanted to learn how the sausage is made! Despite working on a JIT compiler at <a href="https://www.graalvm.org">my day job</a>,
I never actually got to go down in the weeds of instruction encoding and register allocation, and this seemed like the perfect opportunity to learn.</li>
</ul>
<p>So the plan was set: write a small JIT compiler from scratch.
I picked Rust as my implementation language, because <del>I'm a Rust fanboy</del> it's very well suited for this kind of performance work.</p>
<p>Knowing full well that a project like this could ruin my life if I let it, I immediately set down some limitations in scope:</p>
<ul>
<li>Only support one single processor architecture and OS, specifically my laptop's (x86-64 on Linux, and no AVX-512 instructions).</li>
<li>No GPU compute. As much as I would have liked to learn more about GPU compilation, I don't have access to an Nvidia GPU for CUDA.</li>
<li>The use of external libraries should be kept to a minimum, or it would defeat the point of the learning exercise. I thought it fine to use a library for writing the image data to a PNG file, however.</li>
</ul>
<p>Finally, a couple rules of thumb for the rest of this blog post:</p>
<ul>
<li>I'll be assuming you have some knowledge of Rust syntax and know the basics of computer architecture.</li>
<li>Code examples will usually be simplified compared to their final optimized versions. If you want to see the actual final version of the code, head over to <a href="https://github.com/CRefice/prospero.vm">the GitHub repository</a>.</li>
</ul>
<p>Okay, enough foreplay. Let's get started!</p>
<h2 id="instruction-representation">Instruction representation</h2>
<p>First up: we need a way to represent VM instructions in our compiler.
I've gone back and forth on what exact representation should be used, and this the shape it ended up taking by the end:</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#a7adba;">/// A single VM instruction.
</span><span style="color:#b48ead;">enum </span><span>Instr {
</span><span>    VarX,
</span><span>    VarY,
</span><span>    Const(</span><span style="color:#b48ead;">f32</span><span>),
</span><span>    Unary {
</span><span>        op: UnaryOpcode,
</span><span>        operand: VarId,
</span><span>    },
</span><span>    Binary {
</span><span>        op: BinaryOpcode,
</span><span>        lhs: VarId,
</span><span>        rhs: VarId,
</span><span>    },
</span><span>}
</span><span>
</span><span style="color:#a7adba;">/// Index type for accessing an instruction from a Vec of instructions.
</span><span style="color:#b48ead;">struct </span><span>VarId(</span><span style="color:#b48ead;">u32</span><span>);
</span><span>
</span><span style="color:#a7adba;">/// Operation types for instructions with a single operand.
</span><span style="color:#b48ead;">enum </span><span>UnaryOpcode {
</span><span>    Neg,
</span><span>    Square,
</span><span>    Sqrt,
</span><span>}
</span><span>
</span><span style="color:#a7adba;">/// Operation types for instructions with two operands.
</span><span style="color:#b48ead;">enum </span><span>BinaryOpcode {
</span><span>    Add,
</span><span>    Sub,
</span><span>    Mul,
</span><span>    Max,
</span><span>    Min,
</span><span>}
</span></code></pre>
<p>Nothing too surprising here, though there are a few decisions worth explaining:</p>
<ul>
<li>Instructions are parsed into a single flat <code>Vec</code>, and variable handles (<code>VarId</code>s) are just newtype'd indices into this <code>Vec</code>.
This is the classic Rust trick of representing graphs as flattened arrays instead of separate heap-allocated objects with pointers between them,
which is much more cache-friendly, and also helps appease the almighty borrow checker.</li>
<li>The <code>Instr</code> enum is not flattened (with one variant per opcode), instead instructions are grouped into unary (e.g. <code>square x</code>) and binary (e.g. <code>add x y</code>).
This is much more ergonomic when doing pretty much anything with those instructions other than parsing them, and I'd honestly recommend this pattern for any kind of compiler-like project.</li>
<li>You might be tempted to reduce the number of unique opcodes for the sake of implementation simplicity.
For example, <code>square x</code> is essentially equivalent to <code>mul x x</code>, and <code>neg x</code> is equivalent to <code>sub (const 0) x</code>.
However, when it comes time to apply some optimizations to the VM code, you'll need all the information
you can get to drive optimization decisions. So resist that temptation!</li>
</ul>
<p>Actually parsing these instructions from the input text file is really not that interesting, so we'll skip over it here. You can check out <a href="https://github.com/CRefice/prospero.jit/blob/fd05c64402bdccaf3bf4168ac256626fb09226ed/src/lib.rs#L47">the relevant source code</a> if you want to see how that's done.</p>
<h2 id="emitting-cpu-instructions">Emitting CPU instructions</h2>
<p>Now we have the VM instructions in a format we can work with. Can we convert them to actual processor instructions already?
Not so fast! We first need to go on a bit of a tangent about <strong>instruction encoding</strong>.</p>
<p>Every processor architecture has its own set of instructions, and its own special way to encode these instructions into bytes.
Our chosen architecture, x86, is really old, being first introduced in 1978 with Intel's first 16-bit processor.
It has evolved incrementally over the years, with new instructions being essentially bolted on top of the old ones, instead of ever reworking the instruction set from scratch.</p>
<p>As a result, the instruction encoding scheme x86 uses is really quite complicated and unintuitive.
To try and keep things simpler, we'll focus on SIMD instruction encoding only, specifically <strong>AVX</strong>,
the most advanced type of SIMD instructions that my processor supports.
With its 256-bit wide registers, AVX allows us to work with a whopping 8 32-bit floats at once!</p>
<p>An encoded AVX instruction is made up of multiple parts:</p>
<ul>
<li>A <strong><code>VEX</code> prefix</strong>, which can be two or three bytes long and serves both as a marker for "this is an AVX instruction",
and also encodes which registers the instruction will read its operands from. Well, part of this information anyway. More on that in a bit.</li>
<li>An <strong>opcode</strong> byte, which denotes which operation this instruction performs (addition, subtraction, etc.)</li>
<li>A <strong><code>ModR/M</code></strong> byte, which contains the rest of the information on input/output registers not encoded by the VEX prefix.</li>
<li>Further immediate operands such as memory address displacements, constants, etc, depending on the instruction.</li>
</ul>
<p>You might have noticed some repetition there. Why is operand information split between the <code>VEX</code> prefix and the <code>ModR/M</code> byte?</p>
<p>Well, up until fairly recently x86 processors featured only 8 general-purpose registers.
This meant one register could be specified with only 3 bits. So you could specify two registers in one byte (say, one for input and one for output)
and still have two bits left over to specify an addressing mode. This is exactly what the <code>ModR/M</code> byte does.</p>
<p>Later on, x86_64 came along and extended the number of registers to 16.
But, there's no more space available in the <code>ModR/M</code> byte! So the engineers at AMD had two options:</p>
<ul>
<li>Completely change the way register operands are encoded (while still supporting the old way for backwards compatibility).</li>
<li>Finding a couple bits of space somewhere else.</li>
</ul>
<p>Unsurprisingly, they chose the latter, and used part of the instruction prefix to store those fourth bits.
This approach stuck, and is thus used also for AVX instructions.
I told you it was a messy history!</p>
<p>Let's drill further into the <code>VEX</code> prefix, which is probably the most complicated part to understand.
The two-byte version serves only as a shorthand for a three-byte prefix with certain properties, so we'll only look at the three-byte version.
This is what those three bytes look like, bit by bit:</p>
<pre style="background-color:#eff1f5;color:#4f5b66;"><code><span>00-07: 11000100 (0xC4, fixed)
</span><span>08-15: RXBMMMMM
</span><span>16-24: WVVVVLPP
</span></code></pre>
<p>What do does letters mean?</p>
<ul>
<li><code>R</code> and <code>B</code> are those fourth bits of the first and second operand registers we just talked about.</li>
<li><code>X</code> is yet another fourth bit for specifying a register, though it is only useful with an addressing mode we won't be using, so we can safely ignore it.</li>
<li><code>MMMMM</code> is an "opcode map", which is really just additional bits to specify an opcode. This extends the number of possible AVX operations that can be encoded by the instruction set from 256 to 8192.</li>
<li><code>VVVV</code> is an optional third operand register, usually the right-hand side of a binary operation. All four bits are stored together this time, hooray!</li>
<li><code>L</code> specifies the vector width of this instruction: 0 for 128-bit, 1 for 256-bit. Since we want the widest vector available for performance, we'll always set this to 1.</li>
<li><code>W</code> and <code>PP</code>: these are entirely determined by the instruction in question on a case-by-case basis.</li>
</ul>
<p>For some unknown reason, the encoding of <code>R</code>, <code>X</code>, <code>B</code> and <code>VVVV</code> is flipped compared to the number they represent.
So for example, in order to select register 0 as a third operand, the <code>VVVV</code> bits need to be set to 1111. <code>¯\_(ツ)_/¯</code></p>
<p>This is a lot to take in, so let's take the <code>vaddps</code> instruction as an example.
This adds the contents of two registers together, and stores the result in a third register.
Let's take a look at the instruction definition from <a href="https://www.felixcloutier.com/x86/addps">Felix cloutier's x86 instruction listings</a>.
In this case, the third row in the table is the 256-bit version of the instruction, which is the one we're interested in.</p>
<p>We'll ignore the operands for now and just focus on the instruction and the prefix:</p>
<pre style="background-color:#eff1f5;color:#4f5b66;"><code><span>VEX.256.0F.WIG 58 /r VADDPS [...]
</span></code></pre>
<p>Let's break down what this means, part by part:</p>
<ul>
<li><code>VEX</code>: this instruction requires a <code>VEX</code> prefix.</li>
<li><code>256</code>: this is the 256-bit version, so <code>L</code> will be set to 1.</li>
<li><code>0F</code>: this maps to the <code>MMMMM</code> bits, but confusingly, doest not represent the <em>contents</em> of those bits. There's only three values available here:
<code>0F</code> which corresponds to map 1, <code>0F38</code> to 2, and <code>0F3A</code> corresponds to 3. Other maps are so far unused, though could be used for future instruction set extensions. So in this case, <code>MMMMM = 00001</code>.</li>
<li><code>WIG</code>: this means the W bit will be ignored and can thus be set to 0 or 1. If this was <code>W0</code> or <code>W1</code>, the W bit would have to be set accordingly.</li>
<li><code>58</code>: this is the instruction opcode byte (in hexadecimal).</li>
<li>There's no reference to what the <code>PP</code> bits should be set to, so they are set to zero.</li>
</ul>
<p>Let's do another example to really drive the point home, this time with a broadcast instruction, which takes a single 32-bit floating-point number and copies it to all eight slots in a 256-bit vector register.</p>
<pre style="background-color:#eff1f5;color:#4f5b66;"><code><span>VEX.256.66.0F38.W0 18 /r VBROADCASTSS [...]
</span></code></pre>
<ul>
<li><code>VEX.256</code>: same as before.</li>
<li><code>66</code>: careful here: this isn't a value for the opcode map, but actually specifies the <code>PP</code> bits. Once again this is not the value of those bits, but a mapping: <code>66</code> for 1, <code>F3</code> for 2, and <code>F2</code> for 3. No value implies <code>PP = 0</code>, like in the previous example.</li>
<li><code>0F38</code>: as we saw before, this implies an opcode map of 02, so <code>MMMMM = 00010</code></li>
<li><code>W0</code>: <code>W</code> must be set to 0.</li>
<li><code>1A</code>: the instruction opcode.</li>
</ul>
<p>It's a little convoluted, but you quickly start seeing the patterns once you get going.
The ultimate reference for how to read this type of instruction encoding-encoding (text encoding for a binary encoding) is <a href="https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4">Intel's Software Developer Manual</a>, Volume 2, Chapter 3.1.</p>
<p>The last thing left to discuss is operand encoding with the <code>ModR/M</code> byte.</p>
<p>I hand-waved it a bit earlier, but the inputs and outputs to an instruction don't always have to be registers.
They can also be values stored in memory, at addresses which are <em>specified</em> by registers in different ways.
The collective term for ways to specify these addresses is <em>addressing modes</em>, and they're encoded in the top 2 bits of the <code>ModR/M</code> byte.</p>
<p>Being able to read values from memory will be very useful for us soon, so we will make use of two addressing modes:</p>
<ul>
<li>Mode 3, <em>Register-direct</em>: the operand value is the contents of the register in question.</li>
<li>Mode 2, <em>Register-indirect</em>: the operand is read from memory, at an address specified by a base register, plus a 32-bit displacement.
The displacement is encoded directly following the <code>ModR/M</code> byte, as a four-byte number in little-endian byte order.
Essentially, it's like reading the value from an array, where the pointer to that array is stored in a register,
and the index is constant and is encoded in the instruction itself.</li>
</ul>
<p>Alright, we now know enough to actually write some code to write encoded instructions.
We'll start by defining an <code>enum</code> for instruction operands, since we'll want to generate instructions independently of the addressing mode used.</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#bf616a;">derive</span><span>(Debug, Clone, Copy)]
</span><span style="color:#b48ead;">pub enum </span><span>Operand {
</span><span>    </span><span style="color:#a7adba;">/// Register-direct: the operand is the value of the register in question
</span><span>    Register(</span><span style="color:#b48ead;">u8</span><span>),
</span><span>    </span><span style="color:#a7adba;">/// Register-indirect: the operand is the value pointed to by the base register + a 32-bit displacement.
</span><span>    Memory { base: </span><span style="color:#b48ead;">u8</span><span>, disp: </span><span style="color:#b48ead;">u32 </span><span>},
</span><span>}
</span><span>
</span><span style="color:#b48ead;">impl </span><span>Operand {
</span><span>    </span><span style="color:#a7adba;">/// Gets the underlying register that this operand uses to refer to its value.
</span><span>    </span><span style="color:#a7adba;">/// For register-direct mode, this is the operand register itself.
</span><span>    </span><span style="color:#a7adba;">/// For register-indirect mode, this is the base regsiter.
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">register</span><span>(&amp;</span><span style="color:#bf616a;">self</span><span>) -&gt; </span><span style="color:#b48ead;">u8 </span><span>{
</span><span>        </span><span style="color:#b48ead;">match </span><span style="color:#bf616a;">self </span><span>{
</span><span>            Operand::Register(x) =&gt; *x,
</span><span>            Operand::Memory{ base, .. } =&gt; *base,
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>We'll implement the bulk of our encoding logic as member functions of the <code>CodeBuffer</code> struct,
which just pushes bytes into a <code>Vec&lt;u8&gt;</code>.</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#bf616a;">derive</span><span>(Default)]
</span><span style="color:#b48ead;">pub struct </span><span>CodeBuffer {
</span><span>    </span><span style="color:#bf616a;">code</span><span>: Vec&lt;</span><span style="color:#b48ead;">u8</span><span>&gt;,
</span><span>    </span><span style="color:#bf616a;">constants</span><span>: Vec&lt;</span><span style="color:#b48ead;">f32</span><span>&gt;,
</span><span>}
</span></code></pre>
<p>We'll make helper functions for writing <code>VEX</code> prefixes and <code>ModR/M</code> bytes from their constituent parts:</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">impl </span><span>CodeBuffer {
</span><span>    </span><span style="color:#a7adba;">/// Emit the VEX prefix with the given parameters
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">vex</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">reg</span><span>: </span><span style="color:#b48ead;">u8</span><span>, </span><span style="color:#bf616a;">vvvv</span><span>: </span><span style="color:#b48ead;">u8</span><span>, </span><span style="color:#bf616a;">r_m</span><span>: </span><span style="color:#b48ead;">u8</span><span>, </span><span style="color:#bf616a;">pp</span><span>: </span><span style="color:#b48ead;">u8</span><span>, </span><span style="color:#bf616a;">map</span><span>: </span><span style="color:#b48ead;">u8</span><span>) {
</span><span>        </span><span style="color:#bf616a;">self</span><span>.code.</span><span style="color:#96b5b4;">push</span><span>(</span><span style="color:#d08770;">0xc4</span><span>);
</span><span>
</span><span>        {
</span><span>            </span><span style="color:#b48ead;">let</span><span> r_bar = ((!reg) &amp; </span><span style="color:#d08770;">0b1000</span><span>) &gt;&gt; </span><span style="color:#d08770;">3</span><span>;
</span><span>            </span><span style="color:#b48ead;">let</span><span> x_bar = </span><span style="color:#d08770;">1</span><span>;
</span><span>            </span><span style="color:#b48ead;">let</span><span> b_bar = ((!r_m) &amp; </span><span style="color:#d08770;">0b1000</span><span>) &gt;&gt; </span><span style="color:#d08770;">3</span><span>;
</span><span>            </span><span style="color:#b48ead;">let</span><span> mmmmm = map &amp; </span><span style="color:#d08770;">0b11111</span><span>;
</span><span>            </span><span style="color:#bf616a;">self</span><span>.code.</span><span style="color:#96b5b4;">push</span><span>((r_bar &lt;&lt; </span><span style="color:#d08770;">7</span><span>) | (x_bar &lt;&lt; </span><span style="color:#d08770;">6</span><span>) | (b_bar &lt;&lt; </span><span style="color:#d08770;">5</span><span>) | mmmmm);
</span><span>        }
</span><span>
</span><span>        {
</span><span>            </span><span style="color:#b48ead;">let</span><span> w = </span><span style="color:#d08770;">0</span><span>;
</span><span>            </span><span style="color:#b48ead;">let</span><span> vvvv_bar = (!vvvv) &amp; </span><span style="color:#d08770;">0b1111</span><span>;
</span><span>            </span><span style="color:#b48ead;">let</span><span> l = </span><span style="color:#d08770;">1</span><span>;
</span><span>            </span><span style="color:#b48ead;">let</span><span> pp = pp &amp; </span><span style="color:#d08770;">0b11</span><span>;
</span><span>            </span><span style="color:#bf616a;">self</span><span>.code.</span><span style="color:#96b5b4;">push</span><span>((w &lt;&lt; </span><span style="color:#d08770;">7</span><span>) | (vvvv_bar &lt;&lt; </span><span style="color:#d08770;">3</span><span>) | (l &lt;&lt; </span><span style="color:#d08770;">2</span><span>) | pp);
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">/// Emit the ModR/M byte with the given parameters.
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">mod_r_m</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>, r#</span><span style="color:#bf616a;">mod</span><span>: </span><span style="color:#b48ead;">u8</span><span>, </span><span style="color:#bf616a;">reg</span><span>: </span><span style="color:#b48ead;">u8</span><span>, </span><span style="color:#bf616a;">r_m</span><span>: </span><span style="color:#b48ead;">u8</span><span>) {
</span><span>        </span><span style="color:#b48ead;">let</span><span> reg = reg &amp; </span><span style="color:#d08770;">0b111</span><span>;
</span><span>        </span><span style="color:#b48ead;">let</span><span> r_m = r_m &amp; </span><span style="color:#d08770;">0b111</span><span>;
</span><span>        </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#96b5b4;">append</span><span>((r#</span><span style="color:#b48ead;">mod </span><span>&lt;&lt; </span><span style="color:#d08770;">6</span><span>) | (reg &lt;&lt; </span><span style="color:#d08770;">3</span><span>) | r_m);
</span><span>    }
</span><span>}
</span></code></pre>
<p>as well as a function to turn our generic operand into the appropriate <code>ModR/M</code>, addressing mode and all:</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">impl </span><span>CodeBuffer {
</span><span>    </span><span style="color:#a7adba;">/// Emit an appropriate ModR/M byte based on the right-hand operand.
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">operands</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">reg</span><span>: </span><span style="color:#b48ead;">u8</span><span>, </span><span style="color:#bf616a;">r_m</span><span>: Operand) {
</span><span>        </span><span style="color:#b48ead;">match</span><span> r_m {
</span><span>            Operand::Reg(r_m) =&gt; </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#96b5b4;">mod_r_m</span><span>(</span><span style="color:#d08770;">0b11</span><span>, reg, r_m),
</span><span>            Operand::Memory { base, disp } =&gt; {
</span><span>                </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#96b5b4;">mod_r_m</span><span>(</span><span style="color:#d08770;">0b10</span><span>, reg, base);
</span><span>                </span><span style="color:#bf616a;">self</span><span>.code.</span><span style="color:#96b5b4;">extend_from_slice</span><span>(&amp;disp.</span><span style="color:#96b5b4;">to_le_bytes</span><span>());
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>Finally, we'll use these helpers and information from the instruction listings to encode actual instructions.
We don't know yet <em>which</em> operands we will use for those instructions, so they'll be passed in as arguments:</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">impl </span><span>CodeBuffer {
</span><span>    </span><span style="color:#a7adba;">// Note that most VEX instructions only support register-indirect mode for the right-hand operand.
</span><span>    </span><span style="color:#a7adba;">// The left-hand side and output must always be a register, so we represent them directly as `u8`.
</span><span>
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">add</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">dest</span><span>: </span><span style="color:#b48ead;">u8</span><span>, </span><span style="color:#bf616a;">x</span><span>: </span><span style="color:#b48ead;">u8</span><span>, </span><span style="color:#bf616a;">y</span><span>: Operand) {
</span><span>        </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#96b5b4;">vex</span><span>(dest, x, y.</span><span style="color:#96b5b4;">register</span><span>(), </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">1</span><span>);
</span><span>        </span><span style="color:#bf616a;">self</span><span>.code.</span><span style="color:#96b5b4;">push</span><span>(</span><span style="color:#d08770;">0x58</span><span>); </span><span style="color:#a7adba;">// opcode
</span><span>        </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#96b5b4;">operands</span><span>(dest, y);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">sub</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">dest</span><span>: </span><span style="color:#b48ead;">u8</span><span>, </span><span style="color:#bf616a;">x</span><span>: </span><span style="color:#b48ead;">u8</span><span>, </span><span style="color:#bf616a;">y</span><span>: Operand) {
</span><span>        </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#96b5b4;">vex</span><span>(dest, x, y.</span><span style="color:#96b5b4;">register</span><span>(), </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">1</span><span>);
</span><span>        </span><span style="color:#bf616a;">self</span><span>.code.</span><span style="color:#96b5b4;">push</span><span>(</span><span style="color:#d08770;">0x5c</span><span>); </span><span style="color:#a7adba;">// opcode
</span><span>        </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#96b5b4;">operands</span><span>(dest, y);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">broadcast</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">dest</span><span>: </span><span style="color:#b48ead;">u8</span><span>, </span><span style="color:#bf616a;">source</span><span>: Operand) {
</span><span>        </span><span style="color:#a7adba;">// Broacast only supports memory operands
</span><span>        </span><span style="color:#b48ead;">let </span><span>Operand::Memory { base, disp } = source </span><span style="color:#b48ead;">else </span><span>{
</span><span>            unreachable!(&quot;</span><span style="color:#a3be8c;">Cannot broadcast register value: {:?}</span><span>&quot;, source)
</span><span>        };
</span><span>
</span><span>        </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#96b5b4;">vex</span><span>(dest, </span><span style="color:#d08770;">0</span><span>, base, </span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">2</span><span>);
</span><span>        </span><span style="color:#bf616a;">self</span><span>.code.</span><span style="color:#96b5b4;">push</span><span>(</span><span style="color:#d08770;">0x18</span><span>); </span><span style="color:#a7adba;">// opcode
</span><span>        </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#96b5b4;">operands</span><span>(dest, Operand::Memory { base, disp });
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">// And so on...
</span><span>}
</span></code></pre>
<h2 id="register-allocation">Register allocation</h2>
<p>There are two key issues we have been ignoring thus far:</p>
<ul>
<li>How do we pick which registers to use for our instructions?</li>
<li>We only have 16 registers available to use in our machine instructions, yet we have upwards of 7000 variables in our VM instructions,
any of which can be used as an operand for any other. How can we avoid ovewriting a register that contains a value we need to use later?</li>
</ul>
<p>This, of course, is just an instance of the problem of <a href="https://en.wikipedia.org/wiki/Register_allocation">Register Allocation</a>.
We have <code>M</code> "virtual" registers that we want to map onto <code>N</code> physical registers (where <code>M</code> &gt;&gt; <code>N</code>) without losing data in the process.
There are many register allocation algorithms to choose from, each with their strengths and weaknesses.</p>
<p>No matter what approach we choose to juggle our values between registers, we will inevitably come to a point where we don't have any registers left
to hold our values, so we'll need to write some of them to memory. This is known in the literature as register <strong>spilling</strong>.
Spilling incurs a performance penalty, so an optimal register allocation solution would have as few spills as possible.</p>
<p>Unfortunately, optimal register allocation is known to be an NP-complete problem, so we cannot expect to achieve optimal spills
without spending a <strong>lot</strong> of time computing the allocation in the first place.</p>
<p>There is therefore a tradeoff to be made between code that runs faster, and code that is faster to compile.
In a JIT compiler like ours, where compilation also happens at runtime, it is generally a good idea to skew a little more towards the latter compared to an ahead-of-time compiler.</p>
<p>It just so happens, there is an algorithm that does a pretty good job at allocating registers with only a linear (or, well, close to linear) time complexity:
<a href="https://en.wikipedia.org/wiki/Register_allocation#Linear_scan">Linear Scan Register Allocation</a>.</p>
<p>The idea behind it is relatively simple: we first figure out the interval in the instruction stream during which each value is <em>live</em>, meaning the interval between when the value is produced by an instruction and when it is last used as an input to another instruction:</p>
<pre style="background-color:#eff1f5;color:#4f5b66;"><code><span>_0 const 2.95     ───────────────────┐
</span><span>_1 var-x          ───┐               │
</span><span>_2 var-y        ─┐  1-3             0-3
</span><span>_3 mul _1 _2   &lt;─┘ &lt;─┘  ────┐        │
</span><span>_4 add _0 _3               3-6 ─┐ &lt;──┘
</span><span>_5 const 3.675  ─┐          │   │
</span><span>_6 add _5 _3   &lt;─┘ ──┐   &lt;──┘  4-8
</span><span>_7 neg _6      &lt;─────┘ ──┐      │
</span><span>_8 max _4 _7   &lt;─────────┘  &lt;───┘
</span></code></pre>
<p>Then, we walk through the instructions, and assign them to any register that is not currently holding another value, in a greedy manner.
Once a value is no longer live, we free up its register so it can be used by another instruction.</p>
<p>When we run out of registers and need to spill something, we choose the register that holds the value that lives <em>the longest in the future</em>.
This gives us the most bang for the buck, freeing up a register for the longest time possible.</p>
<p>Before we get to implementing the algorithm, we'll define the data structures involved.
Turns out there are quite a few of them that need to be kept in sync as we go, so we'll bundle them into a <code>struct</code>.
We'll get to why each data structure was picked in a second, for now we'll start with the data contained within them.</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#a7adba;">/// Interval in the instruction stream during which a variable is live.
</span><span>#[</span><span style="color:#bf616a;">derive</span><span>(Default, Debug, Clone, Copy, PartialOrd, Ord, PartialEq, Eq)]
</span><span style="color:#b48ead;">struct </span><span>LiveInterval {
</span><span>    </span><span style="color:#a7adba;">/// Index of the last instruction that uses this variable as an operand.
</span><span>    </span><span style="color:#bf616a;">end</span><span>: VarId,
</span><span>    </span><span style="color:#a7adba;">/// Index of the variable this interval refers to.
</span><span>    </span><span style="color:#bf616a;">start</span><span>: VarId,
</span><span>}
</span><span>
</span><span style="color:#b48ead;">struct </span><span>RegisterAllocator {
</span><span>    </span><span style="color:#a7adba;">/// Tracks which register or memory location currently contains which variable.
</span><span>    </span><span style="color:#bf616a;">assigned</span><span>: Vec&lt;Operand&gt;,
</span><span>    </span><span style="color:#a7adba;">/// Binary search tree of currently live intervals, sorted by end time.
</span><span>    </span><span style="color:#bf616a;">active</span><span>: BTreeSet&lt;LiveInterval&gt;,
</span><span>    </span><span style="color:#a7adba;">/// Stack of registers that are not currently holding a live variable.
</span><span>    </span><span style="color:#bf616a;">available_regs</span><span>: Vec&lt;</span><span style="color:#b48ead;">u8</span><span>&gt;,
</span><span>    </span><span style="color:#a7adba;">/// How many variables have we spilled so far.
</span><span>    </span><span style="color:#bf616a;">spill_count</span><span>: </span><span style="color:#b48ead;">u32</span><span>,
</span><span>}
</span></code></pre>
<p>Note how the <code>LiveInterval</code> struct is defined with the <code>end</code> field first, and then <code>start</code>.
This makes it so the default implementation of <code>Ord</code> specified by <code>#[derive(PartialOrd, Ord)]</code>
will sort intervals in order of increasing end time first (and then start time, in case of a tie).
This is exactly the order that the <code>active</code> set will store the currently live intervals in.</p>
<p>At the beginning, the active set is empty, and all registers are available and free to be used by instructions. But, although AVX provides 16 vector registers (known as <code>ymm</code> registers) to play with, we can't make use of all of them for storing variables.
For one, we need to reserve two registers for the <code>x</code> and <code>y</code> parameters, which will be passed in from the calling code.</p>
<p>We also need to save one register for use a <em>scratch</em> register.
This is necessary for operations like negation, which can't be expressed as a single instruction (there is no <code>negps</code> AVX instruction), but must be performed by zeroing out a register, and then subtracting the operand from it. Using a scratch register in these cases saves us from having to spill two registers instead of just one, simplifying the implementation.</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">impl </span><span>RegisterAllocator {
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">new</span><span>(</span><span style="color:#bf616a;">instrs</span><span>: &amp;[Instr]) -&gt; </span><span style="color:#b48ead;">Self </span><span>{
</span><span>        </span><span style="color:#b48ead;">Self </span><span>{
</span><span>            assigned: Vec::with_capacity(instrs.</span><span style="color:#96b5b4;">len</span><span>()),
</span><span>            active: BTreeSet::new(),
</span><span>            </span><span style="color:#a7adba;">// ymm0 and ymm1 are occupied by params,
</span><span>            </span><span style="color:#a7adba;">// keep ymm15 as scratch register for spilled values
</span><span>            available_regs: (</span><span style="color:#d08770;">2</span><span>..</span><span style="color:#d08770;">15</span><span>).</span><span style="color:#96b5b4;">rev</span><span>().</span><span style="color:#96b5b4;">collect</span><span>(),
</span><span>            spill_count: </span><span style="color:#d08770;">0</span><span>,
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>Figuring out the live intervals is straightforward.
Since we'll keep the intervals for all values in a <code>Vec</code> (indexed by the corresponding <code>VarId</code>),
the start of an interval is just its index in the <code>Vec</code>. To avoid redundancy we'll just store the interval ends, like so:</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">impl </span><span>RegisterAllocator {
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">compute_last_usage</span><span>(</span><span style="color:#bf616a;">instrs</span><span>: &amp;[Instr]) -&gt; Vec&lt;VarId&gt; {
</span><span>        </span><span style="color:#b48ead;">let mut</span><span> uses: Vec&lt;VarId&gt; = vec![VarId(</span><span style="color:#d08770;">0</span><span>); instrs.</span><span style="color:#96b5b4;">len</span><span>()];
</span><span>        </span><span style="color:#b48ead;">for </span><span>(id, instr) in instrs.</span><span style="color:#96b5b4;">iter</span><span>().</span><span style="color:#96b5b4;">enumerate</span><span>() {
</span><span>            </span><span style="color:#b48ead;">let</span><span> id = VarId(id as </span><span style="color:#b48ead;">u32</span><span>);
</span><span>            </span><span style="color:#b48ead;">match</span><span> instr {
</span><span>                Instr::Unary { operand, .. } =&gt; {
</span><span>                    uses[operand.</span><span style="color:#d08770;">0 </span><span>as </span><span style="color:#b48ead;">usize</span><span>] = id;
</span><span>                }
</span><span>                Instr::Binary { lhs, rhs, .. } =&gt; {
</span><span>                    uses[lhs.</span><span style="color:#d08770;">0 </span><span>as </span><span style="color:#b48ead;">usize</span><span>] = id;
</span><span>                    uses[rhs.</span><span style="color:#d08770;">0 </span><span>as </span><span style="color:#b48ead;">usize</span><span>] = id;
</span><span>                }
</span><span>                _ =&gt; (),
</span><span>            }
</span><span>        }
</span><span>        uses
</span><span>    }
</span><span>}
</span></code></pre>
<p>We can now sketch out our full register allocation algorithm.
Once we have allocated a register for a VM instruction, we'll have all the information we need to convert it to machine code.
Therefore, we will let the register allocator also drive code generation:</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">impl </span><span>RegisterAllocator {
</span><span>    </span><span style="color:#a7adba;">/// Free up registers for variables that won&#39;t be used again after `cur`.
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">free_dead_registers</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">cur</span><span>: VarId) {
</span><span>        todo!();
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">/// Allocate a register for `instr`, assuming it is live during `interval`, and write the corresponding instruction into `buf`.
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">allocate_instr</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">buf</span><span>: &amp;</span><span style="color:#b48ead;">mut</span><span> CodeBuffer, </span><span style="color:#bf616a;">instr</span><span>: &amp;Instr, </span><span style="color:#bf616a;">interval</span><span>: LiveInterval) {
</span><span>        todo!();
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">/// Write code for all instructions in `instrs` into `buf`.
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">generate_code</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">buf</span><span>: &amp;</span><span style="color:#b48ead;">mut</span><span> CodeBuffer, </span><span style="color:#bf616a;">instrs</span><span>: &amp;[Instr]) {
</span><span>        </span><span style="color:#b48ead;">let</span><span> ends = </span><span style="color:#b48ead;">Self</span><span>::compute_last_usage(instrs);
</span><span>
</span><span>        </span><span style="color:#b48ead;">for </span><span>(i, instr) in instrs.</span><span style="color:#96b5b4;">iter</span><span>().</span><span style="color:#96b5b4;">enumerate</span><span>() {
</span><span>            </span><span style="color:#b48ead;">let</span><span> interval = LiveInterval {
</span><span>                end: ends[i],
</span><span>                start: VarId(i as </span><span style="color:#b48ead;">u32</span><span>),
</span><span>            };
</span><span>
</span><span>            </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#96b5b4;">free_dead_registers</span><span>(interval.start);
</span><span>            </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#96b5b4;">allocate_instr</span><span>(buf, instr, interval);
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>To free up registers for dead variables, we'll make use of the ordering of our active set.
The first variable in the set is the one that "dies" the soonest.
So if that first variable is not dead yet, none of the remaining ones in the set will be either,
and we can exit our loop early.
Otherwise, we use the <code>assigned</code> vector to find the register that is currently holding it, and push it into <code>available_regs</code>:</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">impl </span><span>RegisterAllocator {
</span><span>    </span><span style="color:#a7adba;">/// Free up registers for variables that won&#39;t be used again after `cur`.
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">free_dead_registers</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">cur</span><span>: VarId) {
</span><span>        </span><span style="color:#b48ead;">while let </span><span>Some(i) = </span><span style="color:#bf616a;">self</span><span>.active.</span><span style="color:#96b5b4;">first</span><span>().</span><span style="color:#96b5b4;">copied</span><span>() {
</span><span>            </span><span style="color:#a7adba;">// Bail only if strictly greater, as we free registers
</span><span>            </span><span style="color:#a7adba;">// before allocating a register.
</span><span>            </span><span style="color:#b48ead;">if</span><span> i.end &gt; cur {
</span><span>                </span><span style="color:#b48ead;">break</span><span>;
</span><span>            }
</span><span>            </span><span style="color:#bf616a;">self</span><span>.active.</span><span style="color:#96b5b4;">pop_first</span><span>();
</span><span>            </span><span style="color:#b48ead;">match </span><span style="color:#bf616a;">self</span><span>.assigned[i.start] {
</span><span>                Operand::Reg(reg) =&gt; </span><span style="color:#bf616a;">self</span><span>.available_regs.</span><span style="color:#96b5b4;">push</span><span>(*reg),
</span><span>                _ =&gt; unreachable!(&quot;</span><span style="color:#a3be8c;">Only registers should be active</span><span>&quot;),
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>The actual process of allocating a register is roughly as I described before: if there is a register available, we use it. Otherwise, we have to spill.</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">impl </span><span>RegisterAllocator {
</span><span>    </span><span style="color:#a7adba;">/// Mark tregister `reg` as containing the value that `interval.start` refers to.
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">assign_register</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">reg</span><span>: </span><span style="color:#b48ead;">u8</span><span>, </span><span style="color:#bf616a;">interval</span><span>: LiveInterval) {
</span><span>        </span><span style="color:#bf616a;">self</span><span>.assigned.</span><span style="color:#96b5b4;">push</span><span>(Operand::Reg(reg));
</span><span>        </span><span style="color:#bf616a;">self</span><span>.active.</span><span style="color:#96b5b4;">insert</span><span>(interval);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">/// Generate code for `instr` using `reg` as the destination register, and write it into `buf`.
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">generate_instruction</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">buf</span><span>: &amp;</span><span style="color:#b48ead;">mut</span><span> CodeBuffer, </span><span style="color:#bf616a;">instr</span><span>: &amp;Instr, </span><span style="color:#bf616a;">reg</span><span>: </span><span style="color:#b48ead;">u8</span><span>) {
</span><span>        todo!();
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">/// Spill a register to make room for storing the value computed by `instr`, assuming it is live during `interval`.
</span><span>    </span><span style="color:#a7adba;">/// This also generates code for `instr`.
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">spill</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">buf</span><span>: &amp;</span><span style="color:#b48ead;">mut</span><span> CodeBuffer, </span><span style="color:#bf616a;">instr</span><span>: &amp;Instr, </span><span style="color:#bf616a;">interval</span><span>: LiveInterval) {
</span><span>        todo!()
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">/// Allocate a register for `instr`, assuming it is live during `interval`, and write the corresponding code into `buf`.
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">allocate_instr</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">buf</span><span>: &amp;</span><span style="color:#b48ead;">mut</span><span> CodeBuffer, </span><span style="color:#bf616a;">instr</span><span>: &amp;Instr, </span><span style="color:#bf616a;">interval</span><span>: LiveInterval) {
</span><span>        </span><span style="color:#b48ead;">if let </span><span>Instr::Var(reg) = instr {
</span><span>            </span><span style="color:#a7adba;">// No need to generate anything, arguments are already stored in registers
</span><span>            </span><span style="color:#a7adba;">// at the beginning of the function
</span><span>            </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#96b5b4;">assign_register</span><span>(*reg as </span><span style="color:#b48ead;">u8</span><span>, interval);
</span><span>        } </span><span style="color:#b48ead;">else if let </span><span>Some(reg) = </span><span style="color:#bf616a;">self</span><span>.available_regs.</span><span style="color:#96b5b4;">pop</span><span>() {
</span><span>            </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#96b5b4;">generate_instruction</span><span>(buf, instr, reg);
</span><span>            </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#96b5b4;">assign_register</span><span>(reg, interval);
</span><span>        } </span><span style="color:#b48ead;">else </span><span>{
</span><span>            </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#96b5b4;">spill</span><span>(buf, instr, interval);
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>Earlier I mentioned that, when we need to spill something, we should always pick the interval that lives the longest into the future.</p>
<p>Remember how our active set is ordered by interval end time? We already used that ordering to discard dead intervals,
and we can use it again to pick the longest-lived one: all we have to do is simply pick the greatest element in the set!
This, by the way, is why our active set is a binary search tree and not simply a heap: we need to pop values from it from <em>both</em> ends.</p>
<p>One small complication to our algorithm is that we should also consider the current variable as a spilling candidate.
If that instruction lives longer than the longest-lived one in the active set, there's no point in spilling another value; we should just write the result directly into memory.
Unfortunately AVX does not support writing to memory as an output destination directly, so we'll use our scratch register as a temporary holding ground.</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">impl </span><span>RegisterAllocator {
</span><span>    </span><span style="color:#a7adba;">/// Create a new memory location for values to be spilled to.
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">new_spill_location</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>) -&gt; Operand {
</span><span>        todo!();
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#a7adba;">/// Spill a register to make room for storing the value computed by `instr`, assuming it is live during `interval`.
</span><span>    </span><span style="color:#a7adba;">/// This also generates code for `instr`.
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">spill</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">buf</span><span>: &amp;</span><span style="color:#b48ead;">mut</span><span> CodeBuffer, </span><span style="color:#bf616a;">instr</span><span>: &amp;Instr, </span><span style="color:#bf616a;">interval</span><span>: LiveInterval) {
</span><span>        </span><span style="color:#a7adba;">// Get the longest-lived active interval
</span><span>        </span><span style="color:#b48ead;">let</span><span> candidate = </span><span style="color:#bf616a;">self
</span><span>            .active
</span><span>            .</span><span style="color:#96b5b4;">last</span><span>()
</span><span>            .</span><span style="color:#96b5b4;">copied</span><span>()
</span><span>            .</span><span style="color:#96b5b4;">expect</span><span>(&quot;</span><span style="color:#a3be8c;">There&#39;s no live value to spill</span><span>&quot;);
</span><span>
</span><span>        </span><span style="color:#b48ead;">if</span><span> candidate.end &gt; interval.end {
</span><span>            </span><span style="color:#a7adba;">// Candidate lives the longest, so spill it.
</span><span>            </span><span style="color:#bf616a;">self</span><span>.active.</span><span style="color:#96b5b4;">pop_last</span><span>();
</span><span>
</span><span>            </span><span style="color:#b48ead;">let </span><span>Operand::Reg(reg) = </span><span style="color:#bf616a;">self</span><span>.assigned[candidate.start] </span><span style="color:#b48ead;">else </span><span>{
</span><span>                panic!(&quot;</span><span style="color:#a3be8c;">Cannot spill a memory location: {:?}</span><span>&quot;, </span><span style="color:#bf616a;">self</span><span>.assigned[candidate.start]);
</span><span>            };
</span><span>            </span><span style="color:#b48ead;">let</span><span> new_loc = </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#96b5b4;">new_spill_location</span><span>();
</span><span>            </span><span style="color:#bf616a;">self</span><span>.assigned[candidate.start] = new_loc;
</span><span>
</span><span>            </span><span style="color:#a7adba;">// Write register contents to memory
</span><span>            buf.</span><span style="color:#96b5b4;">mov</span><span>(new_loc, Operand::Reg(reg));
</span><span>            </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#96b5b4;">generate_instruction</span><span>(buf, instr, reg);
</span><span>            </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#96b5b4;">assign_register</span><span>(reg, interval);
</span><span>        } </span><span style="color:#b48ead;">else </span><span>{
</span><span>            </span><span style="color:#a7adba;">// Write result to scratch register
</span><span>            </span><span style="color:#b48ead;">let</span><span> scratch = </span><span style="color:#d08770;">15</span><span>;
</span><span>            </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#96b5b4;">generate_instruction</span><span>(buf, instr, scratch);
</span><span>            </span><span style="color:#b48ead;">let</span><span> mem = </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#96b5b4;">new_spill_location</span><span>();
</span><span>            </span><span style="color:#a7adba;">// Write scratch register to memory
</span><span>            buf.</span><span style="color:#96b5b4;">mov</span><span>(mem, Operand::Reg(scratch));
</span><span>            </span><span style="color:#bf616a;">self</span><span>.assigned.</span><span style="color:#96b5b4;">push</span><span>(mem);
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>One thing I haven't touched on yet: what memory should we spill our values into?
Typically, in most compiled languages, local variables are spilled to the <strong>stack</strong>, a big chunk of preallocated scratch memory that a function can use (mostly) as it sees fit. All it needs to do is allocate and deallocate memory by decrementing or incrementing the <strong>stack pointer</strong> register at the stard and end of the function respectively.</p>
<p>In our case however, I found that this allocation and deallocation has a significant performance overhead,
and it also increased the complexity of the implementation, as the number of spilled variables needs to be determined before generating any code.
So instead, we'll just spill to a heap-allocated buffer that we will allocate once after the code is compiled and then reuse for all runs of our compiled function.</p>
<p>We'll keep the base pointer of our spill buffer in a fixed register (say, <code>rcx</code>), and encode a value's index into this buffer as a constant displacement,
since once we have determined the spill location of a given instruction it won't need to change when evaluating different pixels:</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">impl </span><span>RegisterAllocator {
</span><span>    </span><span style="color:#a7adba;">/// Create a new memory location for values to be spilled to.
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">new_spill_location</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>) -&gt; Operand {
</span><span>        </span><span style="color:#b48ead;">let</span><span> disp = {
</span><span>            </span><span style="color:#b48ead;">let</span><span> slot = </span><span style="color:#bf616a;">self</span><span>.stack_size;
</span><span>            </span><span style="color:#bf616a;">self</span><span>.stack_size += </span><span style="color:#d08770;">1</span><span>;
</span><span>            slot * CodeBuffer::</span><span style="color:#d08770;">VALUE_SIZE
</span><span>        };
</span><span>        Operand::Memory {
</span><span>            base: CodeBuffer::</span><span style="color:#d08770;">RCX</span><span>,
</span><span>            disp,
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>We'll also use a heap-allocated buffer to hold our constants, this time keeping its base pointer in <code>rax</code>.
This way we can use the register-indirect addressing mode for all memory addresses in our program:</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">impl </span><span>CodeBuffer {
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">constant</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">cnst</span><span>: </span><span style="color:#b48ead;">f32</span><span>) -&gt; Operand {
</span><span>        </span><span style="color:#b48ead;">let</span><span> slot = </span><span style="color:#bf616a;">self</span><span>.constants.</span><span style="color:#96b5b4;">len</span><span>() as </span><span style="color:#b48ead;">u32</span><span>;
</span><span>        </span><span style="color:#bf616a;">self</span><span>.constants.</span><span style="color:#96b5b4;">push</span><span>(cnst);
</span><span>        Operand::Memory {
</span><span>            base: </span><span style="color:#b48ead;">Self</span><span>::</span><span style="color:#d08770;">RAX</span><span>,
</span><span>            disp: slot * std::mem::size_of::&lt;</span><span style="color:#b48ead;">f32</span><span>&gt;() as </span><span style="color:#b48ead;">u32</span><span>,
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>And with that final piece of the puzzle, we can generate the actual code for all our instructions:</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">impl </span><span>RegisterAllocator {
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">generate_instruction</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">buf</span><span>: &amp;</span><span style="color:#b48ead;">mut</span><span> CodeBuffer, </span><span style="color:#bf616a;">instr</span><span>: &amp;Instr, </span><span style="color:#bf616a;">dest</span><span>: </span><span style="color:#b48ead;">u8</span><span>) {
</span><span>        </span><span style="color:#b48ead;">match</span><span> instr {
</span><span>            Instr::Var(_) =&gt; (),
</span><span>            Instr::Const(cnst) =&gt; {
</span><span>                </span><span style="color:#b48ead;">let</span><span> cnst = buf.</span><span style="color:#96b5b4;">constant</span><span>(*cnst);
</span><span>                buf.</span><span style="color:#96b5b4;">broadcast</span><span>(dest, cnst);
</span><span>            }
</span><span>            Instr::Unary { op, operand } =&gt; {
</span><span>                </span><span style="color:#b48ead;">let</span><span> x: Operand = </span><span style="color:#bf616a;">self</span><span>.assigned[*operand];
</span><span>                </span><span style="color:#b48ead;">match</span><span> op {
</span><span>                    UnaryOpcode::Neg =&gt; {
</span><span>                        </span><span style="color:#b48ead;">let</span><span> scratch = CodeBuffer::</span><span style="color:#d08770;">SCRATCH</span><span>;
</span><span>                        buf.</span><span style="color:#96b5b4;">xor</span><span>(scratch, scratch, Operand::Reg(scratch));
</span><span>                        buf.</span><span style="color:#96b5b4;">sub</span><span>(dest, scratch, x);
</span><span>                    }
</span><span>                    UnaryOpcode::Sqrt =&gt; buf.</span><span style="color:#96b5b4;">sqrt</span><span>(dest, x),
</span><span>                    </span><span style="color:#a7adba;">/* ... */
</span><span>                }
</span><span>            }
</span><span>            Instr::Binary {op, lhs,rhs} =&gt; {
</span><span>                </span><span style="color:#b48ead;">let</span><span> x: Operand  = </span><span style="color:#bf616a;">self</span><span>.assigned[*lhs];
</span><span>                </span><span style="color:#b48ead;">let</span><span> y: Operand  = </span><span style="color:#bf616a;">self</span><span>.assigned[*rhs];
</span><span>
</span><span>                </span><span style="color:#a7adba;">// Left-hand operand must be a register,
</span><span>                </span><span style="color:#a7adba;">// so load it into a scratch register if it&#39;s in memory
</span><span>                </span><span style="color:#b48ead;">let</span><span> x: </span><span style="color:#b48ead;">u8 </span><span>= </span><span style="color:#b48ead;">match</span><span> x {
</span><span>                    Operand::Reg(reg) =&gt; reg,
</span><span>                    mem @ Operand::Memory { .. } =&gt; {
</span><span>                        buf.</span><span style="color:#96b5b4;">mov</span><span>(Operand::Reg(CodeBuffer::</span><span style="color:#d08770;">SCRATCH</span><span>), mem);
</span><span>                        CodeBuffer::</span><span style="color:#d08770;">SCRATCH
</span><span>                    }
</span><span>                };
</span><span>
</span><span>                </span><span style="color:#b48ead;">match</span><span> op {
</span><span>                    BinaryOpcode::Add =&gt; buf.</span><span style="color:#96b5b4;">add</span><span>(dest, x, y),
</span><span>                    </span><span style="color:#a7adba;">/* and so on ... */
</span><span>                }
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<h2 id="running-the-code">Running the code</h2>
<p>We can pat ourselves on the back here: the hardest part's done! We have successfully converted our VM instruction into actual processor instructions.</p>
<p>Now comes the most exciting part: actually running the code we have generated!
But how can we do that, when all we have is a <code>Vec&lt;u8&gt;</code>?</p>
<p>On POSIX platforms at least, this is how:</p>
<ol>
<li>Allocate one or more <em>pages</em> of memory, enough to fit all the code we generated.</li>
<li>Copy the code to this newly-allocated memory buffer.</li>
<li>Set the correct <em>permissions</em> so that the buffer's contents can be executed as code.</li>
<li>Transfer control to the code with an indirect call to the buffer's address.</li>
</ol>
<p>The first three steps are pretty straightforward to implement with calls to <code>libc</code>.
We'll hold the code buffer in its own struct so that it can be cleanly deallocated when dropped:</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#a7adba;">/// A buffer of finished, immutable generated machine code that can be executed.
</span><span style="color:#b48ead;">pub struct </span><span>InstalledCode {
</span><span>    </span><span style="color:#bf616a;">code_buf</span><span>: </span><span style="color:#b48ead;">*const u8</span><span>,
</span><span>    </span><span style="color:#bf616a;">constants</span><span>: Vec&lt;</span><span style="color:#b48ead;">f32</span><span>&gt;,
</span><span>    </span><span style="color:#bf616a;">stack_size</span><span>: </span><span style="color:#b48ead;">usize</span><span>,
</span><span>    </span><span style="color:#bf616a;">layout</span><span>: Layout,
</span><span>}
</span><span>
</span><span style="color:#b48ead;">impl </span><span>CodeBuffer {
</span><span>    </span><span style="color:#a7adba;">/// Install the code generated so far for execution.
</span><span>    </span><span style="color:#b48ead;">pub fn </span><span style="color:#8fa1b3;">install</span><span>(</span><span style="color:#bf616a;">self</span><span>) -&gt; InstalledCode {
</span><span>        </span><span style="color:#b48ead;">use </span><span>libc::{</span><span style="color:#d08770;">_SC_PAGESIZE</span><span>, sysconf};
</span><span>        </span><span style="color:#b48ead;">let</span><span> page_size = </span><span style="color:#b48ead;">unsafe </span><span>{ </span><span style="color:#96b5b4;">sysconf</span><span>(</span><span style="color:#d08770;">_SC_PAGESIZE</span><span>) } as </span><span style="color:#b48ead;">usize</span><span>;
</span><span>        </span><span style="color:#b48ead;">let</span><span> num_pages = </span><span style="color:#b48ead;">usize</span><span>::max(</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#bf616a;">self</span><span>.code.</span><span style="color:#96b5b4;">len</span><span>().</span><span style="color:#96b5b4;">div_ceil</span><span>(page_size));
</span><span>        </span><span style="color:#b48ead;">let</span><span> layout =
</span><span>            Layout::from_size_align(page_size * num_pages, page_size).</span><span style="color:#96b5b4;">expect</span><span>(&quot;</span><span style="color:#a3be8c;">invalid layout</span><span>&quot;);
</span><span>
</span><span>        </span><span style="color:#b48ead;">unsafe </span><span>{
</span><span>            </span><span style="color:#b48ead;">let</span><span> ptr = alloc::alloc(layout);
</span><span>            </span><span style="color:#b48ead;">if</span><span> ptr.</span><span style="color:#96b5b4;">is_null</span><span>() {
</span><span>                alloc::handle_alloc_error(layout);
</span><span>            }
</span><span>            </span><span style="color:#a7adba;">// Fill with RET instructions for safety, in case something goes wrong
</span><span>            </span><span style="color:#a7adba;">// we&#39;ll at least return from the function.
</span><span>            ptr.</span><span style="color:#96b5b4;">write_bytes</span><span>(</span><span style="color:#d08770;">0xc3</span><span>, layout.</span><span style="color:#96b5b4;">size</span><span>());
</span><span>            </span><span style="color:#a7adba;">// Copy code from readable buffer to executable buffer
</span><span>            ptr.</span><span style="color:#96b5b4;">copy_from_nonoverlapping</span><span>(</span><span style="color:#bf616a;">self</span><span>.code.</span><span style="color:#96b5b4;">as_ptr</span><span>(), </span><span style="color:#bf616a;">self</span><span>.code.</span><span style="color:#96b5b4;">len</span><span>());
</span><span>
</span><span>            </span><span style="color:#a7adba;">// Make memory executable (but not writable)
</span><span>            libc::mprotect(
</span><span>                ptr as </span><span style="color:#b48ead;">*mut </span><span>libc::</span><span style="color:#b48ead;">c_void</span><span>,
</span><span>                layout.</span><span style="color:#96b5b4;">size</span><span>(),
</span><span>                libc::</span><span style="color:#d08770;">PROT_EXEC </span><span>| libc::</span><span style="color:#d08770;">PROT_READ</span><span>,
</span><span>            );
</span><span>
</span><span>            InstalledCode {
</span><span>                code_buf: ptr,
</span><span>                _code_size: </span><span style="color:#bf616a;">self</span><span>.code.</span><span style="color:#96b5b4;">len</span><span>(),
</span><span>                stack_size: </span><span style="color:#bf616a;">self</span><span>.stack_size as </span><span style="color:#b48ead;">usize</span><span>,
</span><span>                constants: </span><span style="color:#bf616a;">self</span><span>.constants,
</span><span>                layout,
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#a7adba;">/// Deallocate the buffer when it falls out of scope.
</span><span style="color:#b48ead;">impl </span><span>Drop </span><span style="color:#b48ead;">for </span><span>InstalledCode {
</span><span>    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">drop</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>) {
</span><span>        </span><span style="color:#b48ead;">use </span><span>std::alloc;
</span><span>        </span><span style="color:#b48ead;">unsafe </span><span>{
</span><span>            </span><span style="color:#a7adba;">// Don&#39;t forget to restore the original protections!
</span><span>            libc::mprotect(
</span><span>                </span><span style="color:#bf616a;">self</span><span>.code_buf as </span><span style="color:#b48ead;">*mut </span><span>libc::</span><span style="color:#b48ead;">c_void</span><span>,
</span><span>                </span><span style="color:#bf616a;">self</span><span>.layout.</span><span style="color:#96b5b4;">size</span><span>(),
</span><span>                libc::</span><span style="color:#d08770;">PROT_READ </span><span>| libc::</span><span style="color:#d08770;">PROT_WRITE</span><span>,
</span><span>            );
</span><span>            alloc::dealloc(</span><span style="color:#bf616a;">self</span><span>.code_buf as </span><span style="color:#b48ead;">*mut u8</span><span>, </span><span style="color:#bf616a;">self</span><span>.layout);
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>Actually transferring control to the code requires a bit more effort.
It would be nice if we could cast a pointer to the code buffer to a function pointer and call it directly, like so:</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#a7adba;">/// 256-bit wide floating-point vector
</span><span style="color:#b48ead;">pub type </span><span>Ymm = std::arch::x86_64::__m256;
</span><span>
</span><span style="color:#b48ead;">impl </span><span>InstalledCode {
</span><span>    </span><span style="color:#b48ead;">pub fn </span><span style="color:#8fa1b3;">invoke</span><span>(&amp;</span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">x</span><span>: Ymm, </span><span style="color:#bf616a;">y</span><span>: Ymm, </span><span style="color:#bf616a;">temp_buf</span><span>: &amp;</span><span style="color:#b48ead;">mut</span><span> [Ymm]) -&gt; Ymm {
</span><span>        </span><span style="color:#b48ead;">unsafe </span><span>{
</span><span>            </span><span style="color:#b48ead;">let</span><span> fn_ptr: </span><span style="color:#b48ead;">extern </span><span>&quot;</span><span style="color:#a3be8c;">sysv64</span><span>&quot; </span><span style="color:#b48ead;">fn</span><span>(</span><span style="color:#b48ead;">*const f32</span><span>, </span><span style="color:#b48ead;">*const</span><span> Ymm, Ymm, Ymm) -&gt; Ymm = </span><span style="color:#b48ead;">unsafe </span><span>{
</span><span>                std::mem::transmute(</span><span style="color:#bf616a;">self</span><span>.code_buf)
</span><span>            };
</span><span>
</span><span>            </span><span style="color:#96b5b4;">fn_ptr</span><span>(</span><span style="color:#bf616a;">self</span><span>.constants.</span><span style="color:#96b5b4;">as_ptr</span><span>(), temp_buf.</span><span style="color:#96b5b4;">as_mut_ptr</span><span>(), x, y)
</span><span>        }
</span><span>    }
</span></code></pre>
<p>There are a couple problems with this approach:</p>
<ul>
<li>We'd need to adjust our generated code to match the used <em>calling convention</em>.
In the snippet above I marked the function as using the <a href="https://wiki.osdev.org/System_V_ABI">System V AMD64</a> calling convention, where the first two arguments are passed in registers <code>rdi</code> and <code>rsi</code>.
That would make it difficult to port this code to platforms that only support other calling conventions.</li>
<li>Other calling conventions on e.g. Windows involve writing arguments to the stack before the call and then the function reading them inside. This is much slower than a direct call.</li>
<li>The correlation between the used calling convention and the order of the registers used is implicit, and requires looking it up on an external reference.</li>
</ul>
<p>So instead, I found it much easier, clearer and more performant to write a bit of <em>inline assembly</em>, which Rust offers very good support for.</p>
<p>We can bind Rust variables to specific registers in the assembly code both as inputs and outputs, and even define which registers the code we're calling will overwrite.
The compiler will then preserve any clobbered registers automatically.</p>
<p>This is what that looks like, lightly annotated:</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">impl </span><span>InstalledCode {
</span><span>    </span><span style="color:#b48ead;">pub fn </span><span style="color:#8fa1b3;">invoke</span><span>(&amp;</span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">x</span><span>: Ymm, </span><span style="color:#bf616a;">y</span><span>: Ymm, </span><span style="color:#bf616a;">temp_buf</span><span>: &amp;</span><span style="color:#b48ead;">mut</span><span> [Ymm]) -&gt; Ymm {
</span><span>        </span><span style="color:#b48ead;">unsafe </span><span>{
</span><span>            </span><span style="color:#b48ead;">let</span><span> fn_ptr = </span><span style="color:#bf616a;">self</span><span>.code_buf;
</span><span>            </span><span style="color:#b48ead;">let</span><span> result: Ymm;
</span><span>            std::arch::asm!(
</span><span>                &quot;</span><span style="color:#a3be8c;">call {}</span><span>&quot;,
</span><span>                </span><span style="color:#a7adba;">// Bind fn_ptr to an arbitrary free register
</span><span>                in(reg) fn_ptr,
</span><span>                </span><span style="color:#a7adba;">// Bind the constants buffer base pointer to rax
</span><span>                in(&quot;</span><span style="color:#a3be8c;">rax</span><span>&quot;) </span><span style="color:#bf616a;">self</span><span>.constants.</span><span style="color:#96b5b4;">as_ptr</span><span>(),
</span><span>                </span><span style="color:#a7adba;">// Bind the spill buffer base pointer to rcx
</span><span>                in(&quot;</span><span style="color:#a3be8c;">rcx</span><span>&quot;) temp_buf.</span><span style="color:#96b5b4;">as_mut_ptr</span><span>(),
</span><span>                </span><span style="color:#a7adba;">// ymm0 is used both to pass the x argument to the function, and to retrieve its return value
</span><span>                </span><span style="color:#96b5b4;">inout</span><span>(&quot;</span><span style="color:#a3be8c;">ymm0</span><span>&quot;) x =&gt; result,
</span><span>                </span><span style="color:#a7adba;">// ymm1 is used as an argument and can be overwritten by the generated code
</span><span>                </span><span style="color:#96b5b4;">inout</span><span>(&quot;</span><span style="color:#a3be8c;">ymm1</span><span>&quot;) y =&gt; _,
</span><span>                </span><span style="color:#a7adba;">// Our generated code can overwrite all remaining ymm registers, so we mark them all as clobbered
</span><span>                </span><span style="color:#96b5b4;">out</span><span>(&quot;</span><span style="color:#a3be8c;">ymm2</span><span>&quot;) _,
</span><span>                </span><span style="color:#96b5b4;">out</span><span>(&quot;</span><span style="color:#a3be8c;">ymm3</span><span>&quot;) _,
</span><span>                </span><span style="color:#96b5b4;">out</span><span>(&quot;</span><span style="color:#a3be8c;">ymm4</span><span>&quot;) _,
</span><span>                </span><span style="color:#96b5b4;">out</span><span>(&quot;</span><span style="color:#a3be8c;">ymm5</span><span>&quot;) _,
</span><span>                </span><span style="color:#96b5b4;">out</span><span>(&quot;</span><span style="color:#a3be8c;">ymm6</span><span>&quot;)  _,
</span><span>                </span><span style="color:#96b5b4;">out</span><span>(&quot;</span><span style="color:#a3be8c;">ymm7</span><span>&quot;)  _,
</span><span>                </span><span style="color:#96b5b4;">out</span><span>(&quot;</span><span style="color:#a3be8c;">ymm8</span><span>&quot;)  _,
</span><span>                </span><span style="color:#96b5b4;">out</span><span>(&quot;</span><span style="color:#a3be8c;">ymm9</span><span>&quot;)  _,
</span><span>                </span><span style="color:#96b5b4;">out</span><span>(&quot;</span><span style="color:#a3be8c;">ymm10</span><span>&quot;) _,
</span><span>                </span><span style="color:#96b5b4;">out</span><span>(&quot;</span><span style="color:#a3be8c;">ymm11</span><span>&quot;) _,
</span><span>                </span><span style="color:#96b5b4;">out</span><span>(&quot;</span><span style="color:#a3be8c;">ymm12</span><span>&quot;) _,
</span><span>                </span><span style="color:#96b5b4;">out</span><span>(&quot;</span><span style="color:#a3be8c;">ymm13</span><span>&quot;) _,
</span><span>                </span><span style="color:#96b5b4;">out</span><span>(&quot;</span><span style="color:#a3be8c;">ymm14</span><span>&quot;) _,
</span><span>                </span><span style="color:#96b5b4;">out</span><span>(&quot;</span><span style="color:#a3be8c;">ymm15</span><span>&quot;) _,
</span><span>                </span><span style="color:#a7adba;">// Let the compiler know that we don&#39;t modify the stack in our generated code
</span><span>                </span><span style="color:#96b5b4;">options</span><span>(nostack),
</span><span>            );
</span><span>            result
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>And that's it! The rest of our program is mostly just boilerplate to allocate an image, call the code repeatedly with the right parameters,
and then convert the result to bytes and store it into the image.</p>
<p>Actually, that last part deserves some explanation.
As we mentioned, the code will evaluate 8 pixels at once, each represented by a 32-bit floating point number.
In order to save those pixels to a black-and-white image, we need to convert those 32-bit floats to 8-bit bytes.</p>
<p>We could simply extract each of them from the vector one by one and write them into the image individually, but it's much more performant to write all of them at once, in parallel.</p>
<p>To do so, we convert the vector of floating-point values to a vector of integers, and then shuffle their bytes around with a couple of <code>pack</code> instructions:</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#a7adba;">/// Convert the 8 floating-point values stored in a ymm register to 8 pixel values to be written into an image buffer.
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">to_image_bytes</span><span>(</span><span style="color:#bf616a;">x</span><span>: Ymm) -&gt; [</span><span style="color:#b48ead;">u8</span><span>; </span><span style="color:#d08770;">8</span><span>] {
</span><span>    </span><span style="color:#b48ead;">unsafe </span><span>{
</span><span>        </span><span style="color:#a7adba;">// Thresholding: convert 8 32-bit floats to 32-bit integers with values of 255 if below 0, and 0 otherwise.
</span><span>        </span><span style="color:#b48ead;">let</span><span> mask = _mm256_cmp_ps::&lt;_CMP_LT_OQ&gt;(x, </span><span style="color:#96b5b4;">_mm256_setzero_ps</span><span>());
</span><span>        </span><span style="color:#b48ead;">let</span><span> mask: __m256i = std::mem::transmute(mask);
</span><span>        </span><span style="color:#b48ead;">let</span><span> ones = </span><span style="color:#96b5b4;">_mm256_set1_epi32</span><span>(</span><span style="color:#d08770;">255</span><span>);
</span><span>        </span><span style="color:#b48ead;">let</span><span> result = </span><span style="color:#96b5b4;">_mm256_and_si256</span><span>(mask, ones);
</span><span>
</span><span>        </span><span style="color:#a7adba;">// Pack down the least significant bytes of each integer so that they are stored in the first 8 bytes of the vector.
</span><span>        </span><span style="color:#b48ead;">let</span><span> result = </span><span style="color:#96b5b4;">_mm256_packus_epi32</span><span>(result, result);
</span><span>        </span><span style="color:#b48ead;">let</span><span> result = </span><span style="color:#96b5b4;">_mm256_packus_epi16</span><span>(result, result);
</span><span>        </span><span style="color:#b48ead;">let</span><span> result =
</span><span>            </span><span style="color:#96b5b4;">_mm256_permutevar8x32_epi32</span><span>(result, </span><span style="color:#96b5b4;">_mm256_setr_epi32</span><span>(</span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">4</span><span>, </span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">5</span><span>, </span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">6</span><span>, </span><span style="color:#d08770;">3</span><span>, </span><span style="color:#d08770;">7</span><span>));
</span><span>
</span><span>        </span><span style="color:#a7adba;">// Extract the first 8 bytes (64 bits) from the vector
</span><span>        _mm256_extract_epi64::&lt;0&gt;(result).</span><span style="color:#96b5b4;">to_le_bytes</span><span>()
</span><span>    }
</span><span>}
</span></code></pre>
<h2 id="debugging">Debugging</h2>
<p>Nothing ever goes right the first time, so it's very likely you'll need to debug the runtime-generated code.
<code>gdb</code> gives us some pretty nice utilities to do that.</p>
<p>The first is setting breakpoints at arbitrary memory addresses, with a nice shorthand syntax for addresses held in variables:</p>
<pre style="background-color:#eff1f5;color:#4f5b66;"><code><span># Stop at the function which transfers control to the generated code
</span><span>break prospero::codegen::InstalledCode::invoke
</span><span>cont
</span><span># Breakpoint hit
</span><span># We are now at the start of the call stub.
</span><span># Set a breakpoint at the actual compiled code address
</span><span>break *fn_ptr
</span><span>cont
</span><span># We are now at the beginning of our runtime-compiled code
</span></code></pre>
<p>We can use the <code>display</code> command to track the instructions we're executing and the contents of our registers as we step through our generated code:</p>
<pre style="background-color:#eff1f5;color:#4f5b66;"><code><span># Disassemble the next 5 instructions following the one we&#39;re currently stopped at
</span><span>display/5i $pc
</span><span># Display the contents of ymmm0 and ymm1 as 8 32-bit floats
</span><span>display $ymm0.v8_float
</span><span>display $ymm1.v8_float
</span><span># Step through the code instruction by instruction
</span><span>si
</span><span>si
</span><span>...
</span></code></pre>
<h2 id="intermediate-results">Intermediate results</h2>
<p>Success! We now have a working solution that generates the correct image using runtime-compiled code.</p>
<p>So, how fast is it?
I used <a href="https://github.com/sharkdp/hyperfine">hyperfine</a> to measure my implementation's runtime across multiple runs.
I originally wanted to compare it against the baseline numpy implementation provided by Matt, but for the life of me I could not get it to work at sizes higher than 256x256 without running out of memory. So, I also wrote an extremely simple interpreter as an additional point of comparison.</p>
<p>The following table shows the results for different image sizes:</p>
<div class="table-wrapper">
<table><thead><tr><th>Image size</th><th>Numpy<br>reference impl.</th><th>Interpreter</th><th>Compiler</th></tr></thead><tbody>
<tr><td>256</td><td>1.564 s</td><td>2.773 s</td><td>13.7 ms</td></tr>
<tr><td>512</td><td>N/A</td><td>10.014 s</td><td>44.2 ms</td></tr>
<tr><td>1024</td><td>N/A</td><td>40.682 s</td><td>162.1 ms</td></tr>
<tr><td>2048</td><td>N/A</td><td>164.528 s</td><td>637.6 ms</td></tr>
<tr><td>4096</td><td>N/A</td><td>693.809 s</td><td>2.546 s</td></tr>
</tbody></table>
</div>
<p>(Experiments were run on an AMD Ryzen 7 6800HS CPU on an 2022 ASUS Zephyrus G14 laptop. Your mileage may vary.)</p>
<p>On average, the compiler is a whopping 250 times faster than the interpreter, and that's all on a single thread!</p>
<p>These results include time taken to parse the instructions from a file and to compile the code,
both of which are negligible: compilation takes on average 700 <em>nanoseconds</em>, and parsing code takes around 850 microseconds
when the instructions file has been cached by the OS after a couple of warm-up runs.</p>
<h2 id="optimization">Optimization</h2>
<p>So of course we handily beat the baseline, that's hardly surprising.
Still, more than 2.5 seconds to render a single 4K frame doesn't exactly scream <em>blazing fast</em> to me.</p>
<p>We have squeezed pretty much all that we could from taking the instructions as they are and turning them into code.
Can we go faster by optimizing the stream of instructions themselves, before they are even compiled?</p>
<p>I initially thought of applying the usual set of generic compiler optimization techniques:
folding constants, removing unused instructions, that kind of thing.
However, some exploratory analysis showed that there weren't that many opportunities for such optimizations.</p>
<p>I suppose that makes sense: if the entire program can be optimized as a whole, it would make more sense to save it back to file in an optimized form, rather than doing this optimization every time the program is run.
In fact, I presume the instruction stream given by the challenge was already optimized as such.
So, back to the drawing board.</p>
<p>The actual breakthrough came by thinking about what all these mathematical expressions are actually computing.
The program encodes a bunch of implicit shape definitions for all the letters shown on the image, that we then evaluate on a grid of pixels.</p>
<p>But, we are always running the same instructions for every pixel of the image.
This means that when we're rendering, say, the start of the first row of text, we're still doing all the work of evaluating the shape of <em>every single character</em> in the entire image, only to throw it away after!
There's no way that characters in the bottom-right part of the image are going to have any effect on the pixels in the top left, so we're just wasting work by even considering them!</p>
<p>If we could <strong>split</strong> the program into a bunch of smaller programs that only evaluate a <strong>chunk</strong> of the image, there would be much less duplicate work involved.</p>
<p>But, if all we have is just a linear chunk of instructions, how do we determine which ones are necessary to evaluate a given chunk and which aren't?</p>
<p>Well, we know that the only inputs to the function we are evaluating are the x and y positions of the pixel in image space.
Every other instruction in the program is a pure mathematical function, and therefore depends only on the parameter values.</p>
<p>If we consider one individual chunk of the image, we also know what <strong>range</strong> the x and y positions will be in for that particular chunk, based on the chunk's boundaries:</p>
<figure>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- Created with Inkscape (http://www.inkscape.org/) -->

<svg
   width="120mm"
   height="115mm"
   viewBox="0 0 120 115"
   version="1.1"
   id="svg1"
   xml:space="preserve"
   xmlns:xlink="http://www.w3.org/1999/xlink"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:svg="http://www.w3.org/2000/svg"><defs
     id="defs1"><filter
       style="color-interpolation-filters:sRGB"
       id="filter22"
       x="0"
       y="0"
       width="1"
       height="1"><feColorMatrix
         values="-1 0 0 0 1 0 -1 0 0 1 0 0 -1 0 1 -0.21 -0.72 -0.07 2 0 "
         result="color2"
         id="feColorMatrix22" /></filter></defs><g
     id="layer1"
     transform="translate(-45.915812,-73.884853)"
     style="opacity:0.75"><image
       width="100"
       height="100"
       preserveAspectRatio="none"
       xlink:href="data:image/png;base64,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&#10;/6/4R+lrqWNLfjwgAAAAAElFTkSuQmCC&#10;"
       id="image1"
       x="55.949699"
       y="83.94249"
       style="filter:url(#filter22)" /></g><g
     id="layer2"
     transform="translate(-76.342888,-60.920265)"
     style="display:inline;fill:#cccccc;fill-opacity:0.860976"><rect
       style="mix-blend-mode:normal;fill:#cccccc;fill-opacity:0.860976;stroke:#5e5e5e;stroke-width:0.265;stroke-dasharray:none;stroke-opacity:1"
       id="rect7"
       width="25"
       height="25"
       x="86.37677"
       y="70.977898" /><rect
       style="mix-blend-mode:normal;fill:#cccccc;fill-opacity:0.860976;stroke:#5e5e5e;stroke-width:0.265;stroke-dasharray:none;stroke-opacity:1"
       id="rect8"
       width="25"
       height="25"
       x="111.37677"
       y="70.977898" /><rect
       style="mix-blend-mode:normal;fill:#cccccc;fill-opacity:0.860976;stroke:#5e5e5e;stroke-width:0.265;stroke-dasharray:none;stroke-opacity:1"
       id="rect9"
       width="25"
       height="25"
       x="136.37677"
       y="70.977898" /><rect
       style="mix-blend-mode:normal;fill:#cccccc;fill-opacity:0.860976;stroke:#5e5e5e;stroke-width:0.265;stroke-dasharray:none;stroke-opacity:1"
       id="rect10"
       width="25"
       height="25"
       x="161.37677"
       y="70.977898" /><rect
       style="mix-blend-mode:normal;fill:#cccccc;fill-opacity:0.860976;stroke:#5e5e5e;stroke-width:0.265;stroke-dasharray:none;stroke-opacity:1"
       id="rect11"
       width="25"
       height="25"
       x="161.37677"
       y="95.977898" /><rect
       style="mix-blend-mode:normal;fill:#cccccc;fill-opacity:0.860976;stroke:#5e5e5e;stroke-width:0.265;stroke-dasharray:none;stroke-opacity:1"
       id="rect12"
       width="25"
       height="25"
       x="136.37677"
       y="95.977898" /><rect
       style="font-variation-settings:normal;display:none;opacity:1;mix-blend-mode:normal;vector-effect:none;fill:#cccccc;fill-opacity:0.860976;stroke:#5e5e5e;stroke-width:0.265;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;-inkscape-stroke:none;stop-color:#000000;stop-opacity:1"
       id="rect13"
       width="25"
       height="25"
       x="111.37677"
       y="95.977898" /><rect
       style="mix-blend-mode:normal;fill:#cccccc;fill-opacity:0.860976;stroke:#5e5e5e;stroke-width:0.265;stroke-dasharray:none;stroke-opacity:1"
       id="rect14"
       width="25"
       height="25"
       x="86.37677"
       y="95.977898" /><rect
       style="mix-blend-mode:normal;fill:#cccccc;fill-opacity:0.860976;stroke:#5e5e5e;stroke-width:0.265;stroke-dasharray:none;stroke-opacity:1"
       id="rect15"
       width="25"
       height="25"
       x="86.37677"
       y="120.9779" /><rect
       style="mix-blend-mode:normal;fill:#cccccc;fill-opacity:0.860976;stroke:#5e5e5e;stroke-width:0.265;stroke-dasharray:none;stroke-opacity:1"
       id="rect16"
       width="25"
       height="25"
       x="111.37677"
       y="120.9779" /><rect
       style="mix-blend-mode:normal;fill:#cccccc;fill-opacity:0.860976;stroke:#5e5e5e;stroke-width:0.265;stroke-dasharray:none;stroke-opacity:1"
       id="rect17"
       width="25"
       height="25"
       x="136.37677"
       y="120.9779" /><rect
       style="mix-blend-mode:normal;fill:#cccccc;fill-opacity:0.860976;stroke:#5e5e5e;stroke-width:0.265;stroke-dasharray:none;stroke-opacity:1"
       id="rect18"
       width="25"
       height="25"
       x="161.37677"
       y="120.9779" /><rect
       style="mix-blend-mode:normal;fill:#cccccc;fill-opacity:0.860976;stroke:#5e5e5e;stroke-width:0.265;stroke-dasharray:none;stroke-opacity:1"
       id="rect19"
       width="25"
       height="25"
       x="136.37677"
       y="145.97789" /><rect
       style="mix-blend-mode:normal;fill:#cccccc;fill-opacity:0.860976;stroke:#5e5e5e;stroke-width:0.265;stroke-dasharray:none;stroke-opacity:1"
       id="rect20"
       width="25"
       height="25"
       x="161.37677"
       y="145.97789" /><rect
       style="mix-blend-mode:normal;fill:#cccccc;fill-opacity:0.860976;stroke:#5e5e5e;stroke-width:0.265;stroke-dasharray:none;stroke-opacity:1"
       id="rect21"
       width="25"
       height="25"
       x="111.37677"
       y="145.97789" /><rect
       style="mix-blend-mode:normal;fill:#cccccc;fill-opacity:0.860976;stroke:#5e5e5e;stroke-width:0.265;stroke-dasharray:none;stroke-opacity:1"
       id="rect22"
       width="25"
       height="25"
       x="86.37677"
       y="145.97789" /></g><g
     id="layer3"
     style="display:inline;fill:#2e2e2e;fill-opacity:1"
     transform="translate(10.033884,7.5576351)"><g
       id="g29"
       transform="translate(-86.491049,-68.92851)"
       style="fill:#2e2e2e;fill-opacity:1"><text
         xml:space="preserve"
         style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:3.52777px;font-family:C059;-inkscape-font-specification:'C059, Normal';font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-east-asian:normal;text-align:center;writing-mode:lr-tb;direction:ltr;text-anchor:middle;fill:#2e2e2e;fill-opacity:1;stroke:none;stroke-width:0.264999;stroke-dasharray:none;stroke-opacity:1"
         x="86.491051"
         y="66.428513"
         id="text24"><tspan
           id="tspan24"
           style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:3.52777px;font-family:C059;-inkscape-font-specification:'C059, Normal';font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-east-asian:normal;fill:#2e2e2e;fill-opacity:1;stroke-width:0.265"
           x="86.491051"
           y="66.428513">-1.0</tspan></text><text
         xml:space="preserve"
         style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:3.52777px;font-family:C059;-inkscape-font-specification:'C059, Normal';font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-east-asian:normal;text-align:center;writing-mode:lr-tb;direction:ltr;text-anchor:middle;fill:#2e2e2e;fill-opacity:1;stroke:none;stroke-width:0.264999;stroke-dasharray:none;stroke-opacity:1"
         x="111.49105"
         y="66.428513"
         id="text25"><tspan
           id="tspan25"
           style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:3.52777px;font-family:C059;-inkscape-font-specification:'C059, Normal';font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-east-asian:normal;fill:#2e2e2e;fill-opacity:1;stroke-width:0.265"
           x="111.49105"
           y="66.428513">-0.5</tspan></text><text
         xml:space="preserve"
         style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:3.52777px;font-family:C059;-inkscape-font-specification:'C059, Normal';font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-east-asian:normal;text-align:center;writing-mode:lr-tb;direction:ltr;text-anchor:middle;fill:#2e2e2e;fill-opacity:1;stroke:none;stroke-width:0.264999;stroke-dasharray:none;stroke-opacity:1"
         x="136.49106"
         y="66.428513"
         id="text26"><tspan
           id="tspan26"
           style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:3.52777px;font-family:C059;-inkscape-font-specification:'C059, Normal';font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-east-asian:normal;fill:#2e2e2e;fill-opacity:1;stroke-width:0.265"
           x="136.49106"
           y="66.428513">0.0</tspan></text><text
         xml:space="preserve"
         style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:3.52777px;font-family:C059;-inkscape-font-specification:'C059, Normal';font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-east-asian:normal;text-align:center;writing-mode:lr-tb;direction:ltr;text-anchor:middle;fill:#2e2e2e;fill-opacity:1;stroke:none;stroke-width:0.264999;stroke-dasharray:none;stroke-opacity:1"
         x="161.49106"
         y="66.428513"
         id="text27"><tspan
           id="tspan27"
           style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:3.52777px;font-family:C059;-inkscape-font-specification:'C059, Normal';font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-east-asian:normal;fill:#2e2e2e;fill-opacity:1;stroke-width:0.265"
           x="161.49106"
           y="66.428513">0.5</tspan></text><text
         xml:space="preserve"
         style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:3.52777px;font-family:C059;-inkscape-font-specification:'C059, Normal';font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-east-asian:normal;text-align:center;writing-mode:lr-tb;direction:ltr;text-anchor:middle;fill:#2e2e2e;fill-opacity:1;stroke:none;stroke-width:0.264999;stroke-dasharray:none;stroke-opacity:1"
         x="186.49106"
         y="66.428513"
         id="text28"><tspan
           id="tspan28"
           style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:3.52777px;font-family:C059;-inkscape-font-specification:'C059, Normal';font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-east-asian:normal;fill:#2e2e2e;fill-opacity:1;stroke-width:0.265"
           x="186.49106"
           y="66.428513">1.0</tspan></text></g><g
       id="g30"
       transform="translate(-85.438147,-66.101285)"
       style="fill:#2e2e2e;fill-opacity:1"><text
         xml:space="preserve"
         style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:3.52777px;font-family:C059;-inkscape-font-specification:'C059, Normal';font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-east-asian:normal;text-align:center;writing-mode:lr-tb;direction:ltr;text-anchor:middle;fill:#2e2e2e;fill-opacity:1;stroke:none;stroke-width:0.264999;stroke-dasharray:none;stroke-opacity:1"
         x="78.438148"
         y="69.601288"
         id="text24-9"><tspan
           id="tspan24-4"
           style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:3.52777px;font-family:C059;-inkscape-font-specification:'C059, Normal';font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-east-asian:normal;fill:#2e2e2e;fill-opacity:1;stroke-width:0.265"
           x="78.438148"
           y="69.601288">1.0</tspan></text><text
         xml:space="preserve"
         style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:3.52777px;font-family:C059;-inkscape-font-specification:'C059, Normal';font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-east-asian:normal;text-align:center;writing-mode:lr-tb;direction:ltr;text-anchor:middle;fill:#2e2e2e;fill-opacity:1;stroke:none;stroke-width:0.264999;stroke-dasharray:none;stroke-opacity:1"
         x="78.454025"
         y="94.585411"
         id="text25-7"><tspan
           id="tspan25-8"
           style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:3.52777px;font-family:C059;-inkscape-font-specification:'C059, Normal';font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-east-asian:normal;fill:#2e2e2e;fill-opacity:1;stroke-width:0.265"
           x="78.454025"
           y="94.585411">0.5</tspan></text><text
         xml:space="preserve"
         style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:3.52777px;font-family:C059;-inkscape-font-specification:'C059, Normal';font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-east-asian:normal;text-align:center;writing-mode:lr-tb;direction:ltr;text-anchor:middle;fill:#2e2e2e;fill-opacity:1;stroke:none;stroke-width:0.264999;stroke-dasharray:none;stroke-opacity:1"
         x="78.424042"
         y="119.6154"
         id="text26-4"><tspan
           id="tspan26-5"
           style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:3.52777px;font-family:C059;-inkscape-font-specification:'C059, Normal';font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-east-asian:normal;fill:#2e2e2e;fill-opacity:1;stroke-width:0.265"
           x="78.424042"
           y="119.6154">0.0</tspan></text><text
         xml:space="preserve"
         style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:3.52777px;font-family:C059;-inkscape-font-specification:'C059, Normal';font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-east-asian:normal;text-align:center;writing-mode:lr-tb;direction:ltr;text-anchor:middle;fill:#2e2e2e;fill-opacity:1;stroke:none;stroke-width:0.264999;stroke-dasharray:none;stroke-opacity:1"
         x="78.439911"
         y="144.59953"
         id="text27-0"><tspan
           id="tspan27-3"
           style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:3.52777px;font-family:C059;-inkscape-font-specification:'C059, Normal';font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-east-asian:normal;fill:#2e2e2e;fill-opacity:1;stroke-width:0.265"
           x="78.439911"
           y="144.59953">-0.5</tspan></text><text
         xml:space="preserve"
         style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:3.52777px;font-family:C059;-inkscape-font-specification:'C059, Normal';font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-east-asian:normal;text-align:center;writing-mode:lr-tb;direction:ltr;text-anchor:middle;fill:#2e2e2e;fill-opacity:1;stroke:none;stroke-width:0.264999;stroke-dasharray:none;stroke-opacity:1"
         x="78.383469"
         y="169.65598"
         id="text28-6"><tspan
           id="tspan28-1"
           style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:3.52777px;font-family:C059;-inkscape-font-specification:'C059, Normal';font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-east-asian:normal;fill:#2e2e2e;fill-opacity:1;stroke-width:0.265"
           x="78.383469"
           y="169.65598">-1.0</tspan></text></g><g
       id="g5"
       transform="translate(5.64353e-7,3.0000001)"><path
         style="font-variation-settings:normal;opacity:1;fill:none;fill-opacity:1;stroke:#e98e83;stroke-width:0.560917;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;paint-order:normal"
         d="M 50,-1 C 49.9982,-2.4079398 37.412514,-1.1239399 37.456256,-2.5896961 37.412514,-1.1239403 25,-2.4967539 25,-1"
         id="path5" /><text
         xml:space="preserve"
         style="font-size:6.35px;font-variation-settings:normal;text-align:center;writing-mode:lr-tb;direction:ltr;text-anchor:middle;opacity:1;fill:#e98e83;fill-opacity:1;stroke:none;stroke-width:0.0846667;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
         x="37.58749"
         y="-3.2899144"
         id="text5"><tspan
           id="tspan5"
           style="font-style:italic;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:6.35px;font-family:C059;-inkscape-font-specification:'C059 Italic';fill:#e98e83;fill-opacity:1;stroke:none;stroke-width:0.0846667;stroke-dasharray:none"
           x="37.58749"
           y="-3.2899144">x</tspan></text></g><g
       id="g5-9"
       style="display:inline;fill:#2e2e2e;fill-opacity:1;stroke-width:1.02658;stroke-dasharray:none"
       transform="rotate(-90,38.704964,38.727769)"><path
         style="font-variation-settings:normal;opacity:1;fill:none;fill-opacity:1;stroke:#4faccb;stroke-width:0.560917;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;paint-order:normal"
         d="M 49.932735,-0.58969709 C 49.930935,-1.9976369 37.412514,-1.1239399 37.456256,-2.5896961 c -0.04374,1.4657558 -12.52352,0.5032451 -12.52352,1.99999901"
         id="path5-0" /><text
         xml:space="preserve"
         style="font-size:6.35px;font-variation-settings:normal;text-align:center;writing-mode:lr-tb;direction:ltr;text-anchor:middle;opacity:1;fill:#add8e6;fill-opacity:1;stroke:none;stroke-width:1.02658;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
         x="-4.2963476"
         y="-36.932735"
         id="text5-8"
         transform="rotate(90)"><tspan
           id="tspan5-8"
           style="font-style:italic;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:6.35px;font-family:C059;-inkscape-font-specification:'C059 Italic';fill:#4faccb;fill-opacity:1;stroke:none;stroke-width:1.02658;stroke-dasharray:none"
           x="-4.2963476"
           y="-36.932735">y</tspan></text></g></g><g
     id="layer4"
     style="display:none"
     transform="translate(10.033884,7.5576351)"><g
       id="g2"
       style="font-variation-settings:normal;opacity:1;fill:#ffb516;fill-opacity:1;stroke:#000000;stroke-width:0.0846667;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;stop-color:#000000;stop-opacity:1"
       transform="matrix(1.9992385,0,0,1.9992385,-34.977914,-28.480198)"><circle
         style="font-variation-settings:normal;fill:#ffb516;fill-opacity:1;stroke:#000000;stroke-width:0.0846667;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;stop-color:#000000;stop-opacity:1"
         id="path1"
         cx="35.27227"
         cy="31.222223"
         r="0.46354169" /><text
         xml:space="preserve"
         style="font-size:2.82222px;font-variation-settings:normal;text-align:end;writing-mode:lr-tb;direction:ltr;text-anchor:end;fill:#ffb516;fill-opacity:1;stroke:#000000;stroke-width:0.0846667;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;stop-color:#000000;stop-opacity:1"
         x="33.501713"
         y="24.999619"
         id="text1"><tspan
           id="tspan1"
           style="font-size:2.82222px;font-variation-settings:normal;text-align:center;text-anchor:middle;fill:#ffb516;fill-opacity:1;stroke:#000000;stroke-width:0.0846667;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;stop-color:#000000;stop-opacity:1"
           x="33.501713"
           y="24.999619">When we are</tspan><tspan
           style="font-size:2.82222px;font-variation-settings:normal;text-align:center;text-anchor:middle;fill:#ffb516;fill-opacity:1;stroke:#000000;stroke-width:0.0846667;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;stop-color:#000000;stop-opacity:1"
           x="33.501713"
           y="28.527393"
           id="tspan2">evaluating this pixel...</tspan></text></g><g
       id="g2-1"
       transform="matrix(1.0671156,0,0,1.0671156,31.66165,52.846956)"
       style="fill:#0084a9;fill-opacity:1;stroke:#000000;stroke-width:0.079375;stroke-dasharray:none;stroke-opacity:1"><circle
         style="fill:#0084a9;fill-opacity:1;stroke:#000000;stroke-width:0.079375;stroke-dasharray:none;stroke-opacity:1"
         id="path1-2"
         cx="35.463543"
         cy="31.536459"
         r="0.46354169" /><text
         xml:space="preserve"
         style="font-size:2.82222px;text-align:end;writing-mode:lr-tb;direction:ltr;text-anchor:end;fill:#0084a9;fill-opacity:1;stroke:#000000;stroke-width:0.079375;stroke-dasharray:none;stroke-opacity:1"
         x="44"
         y="22"
         id="text1-9"><tspan
           style="font-size:2.82222px;text-align:center;text-anchor:middle;fill:#0084a9;fill-opacity:1;stroke:#000000;stroke-width:0.079375;stroke-dasharray:none;stroke-opacity:1"
           x="44"
           y="22"
           id="tspan2-1">we are also</tspan><tspan
           style="font-size:2.82222px;text-align:center;text-anchor:middle;fill:#0084a9;fill-opacity:1;stroke:#000000;stroke-width:0.079375;stroke-dasharray:none;stroke-opacity:1"
           x="44"
           y="25.527775"
           id="tspan3">considering shapes</tspan><tspan
           style="font-size:2.82222px;text-align:center;text-anchor:middle;fill:#0084a9;fill-opacity:1;stroke:#000000;stroke-width:0.079375;stroke-dasharray:none;stroke-opacity:1"
           x="44"
           y="29.05555"
           id="tspan4">all the way out here!</tspan></text></g></g></svg>

</figure>
<p>The consequence of these two facts is that, by starting from the ranges of the x and y parameters, we can determine the range every value in the program can take when evaluated within a given chunk.</p>
<pre style="background-color:#eff1f5;color:#4f5b66;"><code><span>_0 const 2.95       range: [2.95, 2.95] (constant range)
</span><span>_1 var-x            range: [-0.5, 0.0]  (range of input parameter)
</span><span>_2 const 8.13008    range: [8.13008, 8.13008] (constant range)
</span><span>_3 mul _1 _2        range: [−4.06504, 0.0] (obtained from input ranges)
</span><span>_4 add _0 _3        range: [−1.11504, 2.95] 
</span><span>[... etc ...]
</span></code></pre>
<p>Where this becomes especially useful is with the <code>min</code> and <code>max</code> instructions.
If the ranges of the two variables being compared do not overlap, we know at compile time that one of these two variables will always be greater than the other.</p>
<pre style="background-color:#eff1f5;color:#4f5b66;"><code><span># assuming _a has range: [-4.0, 2.0]
</span><span># and  _b has range: [5.0, 7.0]
</span><span># so _b will always be greater than _a
</span><span>_c max _a _b
</span><span># Can be simplified simply to
</span><span>_c _b
</span></code></pre>
<p>So in cases like these, the instruction can be completely replaced with one of its two operands. Not only that, but if the other operand isn't used by any other instruction, we can outright remove it from our chunk-specific program.</p>
<p>In our implementation, we'll do this work in multiple passes.</p>
<p>First, we'll propagate the input parameter ranges through the instructions,
and collect all instruction replacements into a hash map:</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#bf616a;">derive</span><span>(Default, Debug, Clone, Copy)]
</span><span style="color:#b48ead;">pub struct </span><span>Range {
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">min</span><span>: </span><span style="color:#b48ead;">f32</span><span>,
</span><span>    </span><span style="color:#b48ead;">pub </span><span style="color:#bf616a;">max</span><span>: </span><span style="color:#b48ead;">f32</span><span>,
</span><span>}
</span><span>
</span><span style="color:#a7adba;">/// Determines the range of the elements in the given slice.
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">range_of</span><span>(</span><span style="color:#bf616a;">elems</span><span>: &amp;[</span><span style="color:#b48ead;">f32</span><span>]) -&gt; Range {
</span><span>    </span><span style="color:#b48ead;">let</span><span> min = elems.</span><span style="color:#96b5b4;">iter</span><span>().</span><span style="color:#96b5b4;">fold</span><span>(</span><span style="color:#b48ead;">f32</span><span>::</span><span style="color:#d08770;">INFINITY</span><span>, |</span><span style="color:#bf616a;">a</span><span>, &amp;</span><span style="color:#bf616a;">b</span><span>| a.</span><span style="color:#96b5b4;">min</span><span>(b));
</span><span>    </span><span style="color:#b48ead;">let</span><span> max = elems.</span><span style="color:#96b5b4;">iter</span><span>().</span><span style="color:#96b5b4;">fold</span><span>(</span><span style="color:#b48ead;">f32</span><span>::</span><span style="color:#d08770;">NEG_INFINITY</span><span>, |</span><span style="color:#bf616a;">a</span><span>, &amp;</span><span style="color:#bf616a;">b</span><span>| a.</span><span style="color:#96b5b4;">max</span><span>(b));
</span><span>    Range { min, max }
</span><span>}
</span><span>
</span><span style="color:#a7adba;">/// Computes the range of all variables in `instrs` based on the input
</span><span style="color:#a7adba;">/// parameter ranges `x_range` and `y_range`, and compute a mapping
</span><span style="color:#a7adba;">/// of instruction replacements.
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">compute_replacements</span><span>(</span><span style="color:#bf616a;">instrs</span><span>: &amp;[Instr], </span><span style="color:#bf616a;">x_range</span><span>: Range, </span><span style="color:#bf616a;">y_range</span><span>: Range) -&gt; HashMap&lt;VarId, VarId&gt; {
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> ranges: Vec&lt;Range&gt; = vec![Default::default(); instrs.</span><span style="color:#96b5b4;">len</span><span>()];
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> replacements: HashMap&lt;VarId, VarId&gt; = HashMap::new();
</span><span>    </span><span style="color:#b48ead;">for </span><span>(i, instr) in instrs.</span><span style="color:#96b5b4;">iter</span><span>().</span><span style="color:#96b5b4;">enumerate</span><span>() {
</span><span>        </span><span style="color:#b48ead;">let</span><span> range = </span><span style="color:#b48ead;">match</span><span> instr {
</span><span>            Instr::VarX =&gt; x_range,
</span><span>            Instr::VarY =&gt; y_range,
</span><span>            Instr::Const(c) =&gt; Range { min: *c, max: *c },
</span><span>            Instr::Unary { op, operand } =&gt; {
</span><span>                </span><span style="color:#b48ead;">let</span><span> range = &amp;ranges[operand.</span><span style="color:#d08770;">0 </span><span>as </span><span style="color:#b48ead;">usize</span><span>];
</span><span>                </span><span style="color:#b48ead;">use </span><span>UnaryOpcode::*;
</span><span>                </span><span style="color:#b48ead;">match</span><span> op {
</span><span>                    Neg =&gt; Range {
</span><span>                        max: -range.min,
</span><span>                        min: -range.max,
</span><span>                    },
</span><span>                    </span><span style="color:#a7adba;">// We assume that sqrt won&#39;t ever be applied to negative inputs,
</span><span>                    </span><span style="color:#a7adba;">// so we constrain the input range to be non-negative.
</span><span>                    Sqrt =&gt; Range {
</span><span>                        min: range.min.</span><span style="color:#96b5b4;">max</span><span>(</span><span style="color:#d08770;">0.0</span><span>).</span><span style="color:#96b5b4;">sqrt</span><span>(),
</span><span>                        max: range.max.</span><span style="color:#96b5b4;">sqrt</span><span>(),
</span><span>                    },
</span><span>                    Square =&gt; </span><span style="color:#96b5b4;">range_of</span><span>(&amp;[range.min * range.min, range.max * range.max),
</span><span>                }
</span><span>            }
</span><span>            Instr::Binary { op, lhs, rhs } =&gt; {
</span><span>                </span><span style="color:#b48ead;">let</span><span> xr = &amp;ranges[lhs.</span><span style="color:#d08770;">0 </span><span>as </span><span style="color:#b48ead;">usize</span><span>];
</span><span>                </span><span style="color:#b48ead;">let</span><span> yr = &amp;ranges[rhs.</span><span style="color:#d08770;">0 </span><span>as </span><span style="color:#b48ead;">usize</span><span>];
</span><span>                </span><span style="color:#b48ead;">use </span><span>BinaryOpcode::*;
</span><span>                </span><span style="color:#b48ead;">match</span><span> op {
</span><span>                    Add =&gt; Range {
</span><span>                        min: xr.min + yr.min,
</span><span>                        max: xr.max + yr.max,
</span><span>                    },
</span><span>                    Sub =&gt; Range {
</span><span>                        min: xr.min - yr.max,
</span><span>                        max: xr.max - yr.min,
</span><span>                    },
</span><span>                    Mul =&gt; </span><span style="color:#96b5b4;">range_of</span><span>(&amp;[
</span><span>                        xr.min * yr.min,
</span><span>                        xr.min * yr.max,
</span><span>                        xr.max * yr.min,
</span><span>                        xr.max * yr.max,
</span><span>                    ]),
</span><span>                    Max =&gt; {
</span><span>                        </span><span style="color:#b48ead;">if</span><span> xr.min &gt; yr.max {
</span><span>                            </span><span style="color:#a7adba;">// max(x, y) == x
</span><span>                            </span><span style="color:#b48ead;">let</span><span> repl = replacements.</span><span style="color:#96b5b4;">get</span><span>(lhs).</span><span style="color:#96b5b4;">unwrap_or</span><span>(lhs);
</span><span>                            replacements.</span><span style="color:#96b5b4;">insert</span><span>(VarId(i as </span><span style="color:#b48ead;">u32</span><span>), repl);
</span><span>                            *xr
</span><span>                        } </span><span style="color:#b48ead;">else if</span><span> xr.max &lt; yr.min {
</span><span>                            </span><span style="color:#a7adba;">// max(x, y) == y
</span><span>                            </span><span style="color:#b48ead;">let</span><span> repl = replacements.</span><span style="color:#96b5b4;">get</span><span>(rhs).</span><span style="color:#96b5b4;">unwrap_or</span><span>(rhs);
</span><span>                            replacements.</span><span style="color:#96b5b4;">insert</span><span>(VarId(i as </span><span style="color:#b48ead;">u32</span><span>), repl);
</span><span>                            *yr
</span><span>                        } </span><span style="color:#b48ead;">else </span><span>{
</span><span>                            Range {
</span><span>                                min: xr.min.</span><span style="color:#96b5b4;">max</span><span>(yr.min),
</span><span>                                max: xr.max.</span><span style="color:#96b5b4;">max</span><span>(yr.max),
</span><span>                            }
</span><span>                        }
</span><span>                    }
</span><span>                    Min =&gt; {
</span><span>                        </span><span style="color:#b48ead;">if</span><span> xr.min &gt; yr.max {
</span><span>                            </span><span style="color:#a7adba;">// min(x, y) == y
</span><span>                            </span><span style="color:#b48ead;">let</span><span> repl = replacements.</span><span style="color:#96b5b4;">get</span><span>(rhs).</span><span style="color:#96b5b4;">unwrap_or</span><span>(rhs);
</span><span>                            replacements.</span><span style="color:#96b5b4;">insert</span><span>(VarId(i as </span><span style="color:#b48ead;">u32</span><span>), repl);
</span><span>                            *yr
</span><span>                        } </span><span style="color:#b48ead;">else if</span><span> xr.max &lt; yr.min {
</span><span>                            </span><span style="color:#a7adba;">// min(x, y) == x
</span><span>                            </span><span style="color:#b48ead;">let</span><span> repl = replacements.</span><span style="color:#96b5b4;">get</span><span>(lhs).</span><span style="color:#96b5b4;">unwrap_or</span><span>(lhs);
</span><span>                            replacements.</span><span style="color:#96b5b4;">insert</span><span>(VarId(i as </span><span style="color:#b48ead;">u32</span><span>), repl);
</span><span>                            *xr
</span><span>                        } </span><span style="color:#b48ead;">else </span><span>{
</span><span>                            Range {
</span><span>                                min: xr.min.</span><span style="color:#96b5b4;">min</span><span>(yr.min),
</span><span>                                max: xr.max.</span><span style="color:#96b5b4;">min</span><span>(yr.max),
</span><span>                            }
</span><span>                        }
</span><span>                    }
</span><span>                }
</span><span>            }
</span><span>        };
</span><span>        ranges[i] = range;
</span><span>    }
</span><span>    replacements
</span><span>}
</span></code></pre>
<p>With the replacements in hand, we can then apply them to the instructions with a second pass.
We can't replace the instruction directly, so we'll instead modify any instructions that
use the replaced instruction as an input, changing the input to its replacement.</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#a7adba;">/// Modifies `instrs` so that for any (lhs, rhs) pair in `replacements`,
</span><span style="color:#a7adba;">/// all instructions with `lhs` as an operand will now have `rhs` as its operand instead.
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">apply_replacements</span><span>(</span><span style="color:#bf616a;">instrs</span><span>: &amp;</span><span style="color:#b48ead;">mut</span><span> [Instr], </span><span style="color:#bf616a;">replacements</span><span>: &amp;HashMap&lt;VarId, VarId&gt;) {
</span><span>    </span><span style="color:#b48ead;">for</span><span> instr in instrs.</span><span style="color:#96b5b4;">iter_mut</span><span>() {
</span><span>        </span><span style="color:#b48ead;">match</span><span> instr {
</span><span>            Instr::Unary { operand, .. } =&gt; {
</span><span>                *operand = replacements.</span><span style="color:#96b5b4;">get</span><span>(operand).</span><span style="color:#96b5b4;">unwrap_or</span><span>(operand);
</span><span>            }
</span><span>            Instr::Binary { lhs, rhs, .. } =&gt; {
</span><span>                *lhs = replacements.</span><span style="color:#96b5b4;">get</span><span>(lhs).</span><span style="color:#96b5b4;">unwrap_or</span><span>(lhs);
</span><span>                *rhs = replacements.</span><span style="color:#96b5b4;">get</span><span>(rhs).</span><span style="color:#96b5b4;">unwrap_or</span><span>(rhs);
</span><span>            }
</span><span>            _ =&gt; (),
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>With this we have optimized each instruction individually, but the instruction stream is still left with a bunch of unused instructions.
We will clean them up in one more pass (or well, technically two passes).</p>
<p>Since in our implementation variable IDs are just their indices in a <code>Vec</code>, removing
an instruction from that <code>Vec</code> will also involve adjusting the IDs of all following instructions:</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#a7adba;">/// Returns a boolean vector where each element represents
</span><span style="color:#a7adba;">/// where the corresponding instruction in `instrs` is used
</span><span style="color:#a7adba;">/// by any other instruction in `instrs`.
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">compute_instr_usage</span><span>(</span><span style="color:#bf616a;">instrs</span><span>: &amp;[Instr]) -&gt; Vec&lt;</span><span style="color:#b48ead;">bool</span><span>&gt; {
</span><span>    </span><span style="color:#a7adba;">// We could also do this with a bitset, but this is less complex
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> is_used = vec![</span><span style="color:#d08770;">false</span><span>; instrs.</span><span style="color:#96b5b4;">len</span><span>()];
</span><span>    </span><span style="color:#a7adba;">// Return value is always used
</span><span>    *is_used.</span><span style="color:#96b5b4;">last_mut</span><span>().</span><span style="color:#96b5b4;">unwrap</span><span>() = </span><span style="color:#d08770;">true</span><span>;
</span><span>    </span><span style="color:#a7adba;">// Propagate is_used from last to first
</span><span>    </span><span style="color:#b48ead;">for </span><span>(i, instr) in instrs.</span><span style="color:#96b5b4;">iter</span><span>().</span><span style="color:#96b5b4;">enumerate</span><span>().</span><span style="color:#96b5b4;">rev</span><span>() {
</span><span>        </span><span style="color:#b48ead;">if</span><span> is_used[i] {
</span><span>            </span><span style="color:#b48ead;">match</span><span> instr {
</span><span>                Instr::Unary { operand, .. } =&gt; {
</span><span>                    is_used[operand.</span><span style="color:#d08770;">0 </span><span>as </span><span style="color:#b48ead;">usize</span><span>] = </span><span style="color:#d08770;">true</span><span>;
</span><span>                }
</span><span>                Instr::Binary { lhs, rhs, .. } =&gt; {
</span><span>                    is_used[lhs.</span><span style="color:#d08770;">0 </span><span>as </span><span style="color:#b48ead;">usize</span><span>] = </span><span style="color:#d08770;">true</span><span>;
</span><span>                    is_used[rhs.</span><span style="color:#d08770;">0 </span><span>as </span><span style="color:#b48ead;">usize</span><span>] = </span><span style="color:#d08770;">true</span><span>;
</span><span>                }
</span><span>                _ =&gt; (),
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>    is_used
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">cleanup_unused</span><span>(</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">instrs</span><span>: Vec&lt;Instr&gt;) -&gt; Vec&lt;Instr&gt; {
</span><span>    </span><span style="color:#a7adba;">// First pass: track which instructions are used in a `Vec&lt;bool&gt;`.
</span><span>    </span><span style="color:#b48ead;">let</span><span> is_used = </span><span style="color:#96b5b4;">compute_instr_usage</span><span>(&amp;instrs);
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Second pass: remove any instructions for which is_used[i] == false
</span><span>
</span><span>    </span><span style="color:#a7adba;">// Removing an instructions from the stream will change the index of
</span><span>    </span><span style="color:#a7adba;">// all following instructions, so we maintain a mapping from old ID to new ID
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> id_mapping = Vec::new();
</span><span>
</span><span>    </span><span style="color:#a7adba;">// How many instructions have we kept so far.
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> retained = </span><span style="color:#d08770;">0</span><span style="color:#b48ead;">u32</span><span>;
</span><span>
</span><span>    instrs
</span><span>        .</span><span style="color:#96b5b4;">into_iter</span><span>()
</span><span>        .</span><span style="color:#96b5b4;">zip</span><span>(is_used)
</span><span>        .</span><span style="color:#96b5b4;">filter_map</span><span>(|</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">instr</span><span>, </span><span style="color:#bf616a;">is_used</span><span>| {
</span><span>            id_mapping.</span><span style="color:#96b5b4;">push</span><span>(VarId(retained));
</span><span>            </span><span style="color:#b48ead;">if </span><span>!is_used {
</span><span>                </span><span style="color:#b48ead;">return </span><span>None;
</span><span>            }
</span><span>            </span><span style="color:#b48ead;">match </span><span>&amp;</span><span style="color:#b48ead;">mut</span><span> instr {
</span><span>                Instr::Unary { operand, .. } =&gt; {
</span><span>                    *operand = id_mapping[operand.</span><span style="color:#d08770;">0 </span><span>as </span><span style="color:#b48ead;">usize</span><span>];
</span><span>                }
</span><span>                Instr::Binary { lhs, rhs, .. } =&gt; {
</span><span>                    *lhs = id_mapping[lhs.</span><span style="color:#d08770;">0 </span><span>as </span><span style="color:#b48ead;">usize</span><span>];
</span><span>                    *rhs = id_mapping[rhs.</span><span style="color:#d08770;">0 </span><span>as </span><span style="color:#b48ead;">usize</span><span>];
</span><span>                }
</span><span>                _ =&gt; (),
</span><span>            };
</span><span>            Some(instr)
</span><span>        })
</span><span>        .</span><span style="color:#96b5b4;">collect</span><span>()
</span><span>}
</span></code></pre>
<p>And with that, we have our whole optimization pipeline to obtain a version of the function specialized to a single chunk:</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#a7adba;">/// Computes an optimized stream of instructions for the image chunk defined by `x_range` and `y_range`.
</span><span style="color:#b48ead;">pub fn </span><span style="color:#8fa1b3;">specialize</span><span>(</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">instrs</span><span>: Vec&lt;Instr&gt;, </span><span style="color:#bf616a;">x_range</span><span>: Range, </span><span style="color:#bf616a;">y_range</span><span>: Range) -&gt; Vec&lt;Instr&gt; {
</span><span>    </span><span style="color:#b48ead;">let</span><span> replacements = </span><span style="color:#96b5b4;">compute_ranges</span><span>(&amp;instrs, x_range, y_range);
</span><span>    </span><span style="color:#a7adba;">// If the returned instruction has a replacement, we can directly
</span><span>    </span><span style="color:#a7adba;">// truncate the array so that its replacement is the new last instruction,
</span><span>    </span><span style="color:#a7adba;">// as all instructions in between will for sure be unused.
</span><span>    </span><span style="color:#b48ead;">let</span><span> ret = VarId(instrs.</span><span style="color:#96b5b4;">len</span><span>() - </span><span style="color:#d08770;">1</span><span>);
</span><span>    </span><span style="color:#b48ead;">if let </span><span>Some(ret) = replacements.</span><span style="color:#96b5b4;">get</span><span>(ret) {
</span><span>        instrs.</span><span style="color:#96b5b4;">truncate</span><span>(ret.</span><span style="color:#d08770;">0 </span><span>as </span><span style="color:#b48ead;">usize </span><span>+ </span><span style="color:#d08770;">1</span><span>);
</span><span>    }
</span><span>    </span><span style="color:#96b5b4;">apply_replacements</span><span>(&amp;</span><span style="color:#b48ead;">mut</span><span> instrs, &amp;replacements);
</span><span>    </span><span style="color:#96b5b4;">cleanup_unused</span><span>(instrs)
</span><span>}
</span></code></pre>
<p>Feel free to read <a href="https://github.com/CRefice/prospero.jit/blob/e8677025e7abdfcb55642097d84a1ddd65c7f82e/src/main.rs#L191">the source code on GitHub</a> to see how this type of specialization is used in the final version of the code.</p>
<h2 id="multithreading-and-borrow-checker-issues">Multithreading and borrow checker issues</h2>
<p>Initially, I didn't want to talk about multithreading in this blog post as it's really not that interesting in the scope of this challenge:
image rendering is embarrassingly parallel, so distributing the work across N processor cores will in theory achieve
an almost N-fold speedup over doing it serially.</p>
<p>I did however want to implement multi-threading anyway, for the sake of making the final results look as good as possible.
In the process, I ran into a Rust borrow-checker issue I thought was worth talking about.</p>
<p>Instead of bringing in <code>rayon</code> as a dependency, I thought to use the recently stabilized feature of <a href="https://doc.rust-lang.org/std/thread/fn.scope.html">scoped threads</a>.
For the sake of simplicity we'll use it in a pretty "dumb" way, spawning one thread per image chunk.
This looks roughly as follows:</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">let mut</span><span> image = vec![</span><span style="color:#d08770;">0</span><span style="color:#b48ead;">u8</span><span>; image_size * image_size];
</span><span style="color:#b48ead;">let</span><span> chunk_size = image_size / num_splits;
</span><span>std::thread::scope(|</span><span style="color:#bf616a;">s</span><span>| {
</span><span>    </span><span style="color:#b48ead;">for </span><span>(y, row) in specialized.</span><span style="color:#96b5b4;">into_iter</span><span>().</span><span style="color:#96b5b4;">enumerate</span><span>() {
</span><span>        </span><span style="color:#b48ead;">for </span><span>(x, code) in row.</span><span style="color:#96b5b4;">into_iter</span><span>().</span><span style="color:#96b5b4;">enumerate</span><span>() {
</span><span>            </span><span style="color:#a7adba;">// Spawn a separate thread to process each chunk of the image
</span><span>            s.</span><span style="color:#96b5b4;">spawn</span><span>(</span><span style="color:#b48ead;">move </span><span>|| {
</span><span>                </span><span style="color:#b48ead;">let</span><span> start_y = y * chunk_size;
</span><span>                </span><span style="color:#b48ead;">let</span><span> end_y = start_y + chunk_size;
</span><span>                </span><span style="color:#b48ead;">let</span><span> start_x = x * chunk_size;
</span><span>                </span><span style="color:#b48ead;">let</span><span> end_x = start_x + chunk_size;
</span><span>                </span><span style="color:#a7adba;">// process image[start_y..end_y][start_x..end_x]
</span><span>            });
</span><span>        }
</span><span>    }
</span><span>});
</span></code></pre>
<p>The problem is, as soon as you try taking a mutable reference to <code>image</code>, the borrow checker will yell at you:</p>
<pre style="background-color:#eff1f5;color:#4f5b66;"><code><span>error[E0499]: cannot borrow `image` as mutable more than once at a time
</span><span>   --&gt; src/main.rs:97:21
</span><span>    |
</span><span>92  |       std::thread::scope(|s| {
</span><span>    |                           - has type `&amp;&#39;1 Scope&lt;&#39;1, &#39;_&gt;`
</span><span>...
</span><span>97  |               s.spawn(|| {
</span><span>    |               -       ^^ `image` was mutably borrowed here in the previous iteration of the loop
</span><span>    |  _____________|
</span><span>    | |
</span><span>    | |                     &lt;snip&gt;
</span><span>...   |
</span><span>137 | |             });
</span><span>    | |______________- argument requires that `image` is borrowed for `&#39;1`
</span><span>
</span></code></pre>
<p>In theory, what we're doing here should be perfectly sound.
There is no data race, nor any need for synchronization; each thread is independently writing to a separate chunk of the image.</p>
<p>The problem is, the Rust compiler cannot <em>prove</em> that we're actually writing to separate chunks. All it sees is the image being borrowed mutably across multiple threads, and throws up its hands.</p>
<p>If we were dealing with a 1D array, <code>Vec::chunks_mut</code> would be a good way to solve this:</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">let</span><span> image: Vec&lt;</span><span style="color:#b48ead;">u8</span><span>&gt; = </span><span style="color:#a7adba;">/*...*/</span><span>;
</span><span>std::thread::scope(|</span><span style="color:#bf616a;">s</span><span>| {
</span><span>    </span><span style="color:#b48ead;">for</span><span> chunk in image.</span><span style="color:#96b5b4;">into_iter</span><span>().</span><span style="color:#96b5b4;">chunks_mut</span><span>(chunk_size) {
</span><span>        s.</span><span style="color:#96b5b4;">spawn</span><span>(</span><span style="color:#b48ead;">move </span><span>|| {
</span><span>            </span><span style="color:#a7adba;">// write to chunk
</span><span>        });
</span><span>    }
</span><span>});
</span></code></pre>
<p>But with a 2D array, each thread isn't accessing a contiguous slice of memory, so things get a bit harder.
The simplest way I found to get around this is with some <code>unsafe</code>, pulling the wool over the compiler's eyes by converting the <code>image</code> slice to a pointer, and wrapping that in a struct which implements <code>Send</code> and can convert the pointer back to a slice:</p>
<pre data-lang="rust" style="background-color:#eff1f5;color:#4f5b66;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#a7adba;">/// Allows sharing a `&amp;mut [u8]` between threads.
</span><span style="color:#b48ead;">struct </span><span>Smuggle(</span><span style="color:#b48ead;">*mut u8</span><span>);
</span><span style="color:#b48ead;">unsafe impl </span><span>Send </span><span style="color:#b48ead;">for </span><span>Smuggle {}
</span><span style="color:#b48ead;">impl </span><span>Smuggle {
</span><span>    </span><span style="color:#b48ead;">unsafe fn </span><span style="color:#8fa1b3;">as_slice</span><span>(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">len</span><span>: </span><span style="color:#b48ead;">usize</span><span>) -&gt; &amp;</span><span style="color:#b48ead;">mut </span><span>[</span><span style="color:#b48ead;">u8</span><span>] {
</span><span>        </span><span style="color:#b48ead;">unsafe </span><span>{ std::slice::from_raw_parts_mut(</span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#d08770;">0</span><span>, len) }
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#a7adba;">/* [...] */
</span><span>
</span><span style="color:#b48ead;">let</span><span> chunk_size = image_size / num_splits;
</span><span>std::thread::scope(|</span><span style="color:#bf616a;">s</span><span>| {
</span><span>    </span><span style="color:#b48ead;">for </span><span>(y, row) in specialized.</span><span style="color:#96b5b4;">into_iter</span><span>().</span><span style="color:#96b5b4;">enumerate</span><span>() {
</span><span>        </span><span style="color:#b48ead;">for </span><span>(x, code) in row.</span><span style="color:#96b5b4;">into_iter</span><span>().</span><span style="color:#96b5b4;">enumerate</span><span>() {
</span><span>            </span><span style="color:#a7adba;">// Smuggle the image past the borrow checker
</span><span>            </span><span style="color:#b48ead;">let mut</span><span> image = Smuggle(image.</span><span style="color:#96b5b4;">as_mut_ptr</span><span>());
</span><span>            s.</span><span style="color:#96b5b4;">spawn</span><span>(</span><span style="color:#b48ead;">move </span><span>|| {
</span><span>                </span><span style="color:#b48ead;">let</span><span> start_y = y * chunk_size;
</span><span>                </span><span style="color:#b48ead;">let</span><span> end_y = start_y + chunk_size;
</span><span>                </span><span style="color:#b48ead;">let</span><span> start_x = x * chunk_size;
</span><span>                </span><span style="color:#b48ead;">let</span><span> end_x = start_x + chunk_size;
</span><span>                </span><span style="color:#b48ead;">let</span><span> image = </span><span style="color:#b48ead;">unsafe </span><span>{ image.</span><span style="color:#96b5b4;">as_slice</span><span>(image_size * image_size) };
</span><span>                </span><span style="color:#a7adba;">// process image[start_y..end_y][start_x..end_x]
</span><span>            });
</span><span>        }
</span><span>    }
</span><span>});
</span></code></pre>
<h2 id="final-results">Final results</h2>
<p>By splitting up the image into chunks, and running a specialized version of the program for each chunk,
we will perform a lot less duplicate work, and the function will be evaluated a lot faster.</p>
<p>But, there is still a trade-off as to how many chunks we split the image into.
Too few chunks, and we'll still be doing a lot of duplicate work when running the compiled program.
Too many, and we'll spend more time compiling all the different specialized versions of the program than actually running them.</p>
<p>The following graph shows the total runtime of running the example program at the same image size of 4096x4096 but with different chunk sizes,
broken up into compilation time and evaluation time.</p>
<figure>
<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
  "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="504pt" height="288pt" viewBox="0 0 504 288" xmlns="http://www.w3.org/2000/svg" version="1.1">
 <metadata>
  <rdf:RDF xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:cc="http://creativecommons.org/ns#" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
   <cc:Work>
    <dc:type rdf:resource="http://purl.org/dc/dcmitype/StillImage"/>
    <dc:date>2025-04-25T14:58:32.686610</dc:date>
    <dc:format>image/svg+xml</dc:format>
    <dc:creator>
     <cc:Agent>
      <dc:title>Matplotlib v3.10.1, https://matplotlib.org/</dc:title>
     </cc:Agent>
    </dc:creator>
   </cc:Work>
  </rdf:RDF>
 </metadata>
 <defs>
  <style type="text/css">*{stroke-linejoin: round; stroke-linecap: butt}</style>
 </defs>
 <g id="figure_1">
  <g id="patch_1">
   <path d="M 0 288 
L 504 288 
L 504 0 
L 0 0 
z
" style="fill: #ffffff"/>
  </g>
  <g id="axes_1">
   <g id="patch_2">
    <path d="M 63 256.32 
L 453.6 256.32 
L 453.6 34.56 
L 63 34.56 
z
" style="fill: #ffffff"/>
   </g>
   <g id="patch_3">
    <path d="M 67.34 75123.036752 
L 102.06 75123.036752 
L 102.06 44.64 
L 67.34 44.64 
z
" clip-path="url(#p4d30eba118)" style="fill: #b4d4df"/>
   </g>
   <g id="patch_4">
    <path d="M 110.74 75123.036752 
L 145.46 75123.036752 
L 145.46 83.181803 
L 110.74 83.181803 
z
" clip-path="url(#p4d30eba118)" style="fill: #b4d4df"/>
   </g>
   <g id="patch_5">
    <path d="M 154.14 75123.036752 
L 188.86 75123.036752 
L 188.86 127.27828 
L 154.14 127.27828 
z
" clip-path="url(#p4d30eba118)" style="fill: #b4d4df"/>
   </g>
   <g id="patch_6">
    <path d="M 197.54 75123.036752 
L 232.26 75123.036752 
L 232.26 178.127805 
L 197.54 178.127805 
z
" clip-path="url(#p4d30eba118)" style="fill: #b4d4df"/>
   </g>
   <g id="patch_7">
    <path d="M 240.94 75123.036752 
L 275.66 75123.036752 
L 275.66 192.465288 
L 240.94 192.465288 
z
" clip-path="url(#p4d30eba118)" style="fill: #b4d4df"/>
   </g>
   <g id="patch_8">
    <path d="M 284.34 75123.036752 
L 319.06 75123.036752 
L 319.06 188.928587 
L 284.34 188.928587 
z
" clip-path="url(#p4d30eba118)" style="fill: #b4d4df"/>
   </g>
   <g id="patch_9">
    <path d="M 327.74 75123.036752 
L 362.46 75123.036752 
L 362.46 181.048732 
L 327.74 181.048732 
z
" clip-path="url(#p4d30eba118)" style="fill: #b4d4df"/>
   </g>
   <g id="patch_10">
    <path d="M 371.14 75123.036752 
L 405.86 75123.036752 
L 405.86 169.604855 
L 371.14 169.604855 
z
" clip-path="url(#p4d30eba118)" style="fill: #b4d4df"/>
   </g>
   <g id="patch_11">
    <path d="M 414.54 75123.036752 
L 449.26 75123.036752 
L 449.26 157.476329 
L 414.54 157.476329 
z
" clip-path="url(#p4d30eba118)" style="fill: #b4d4df"/>
   </g>
   <g id="patch_12">
    <path d="M 67.34 75123.036752 
L 102.06 75123.036752 
L 102.06 44.640063 
L 67.34 44.640063 
z
" clip-path="url(#p4d30eba118)" style="fill: #e98e83"/>
   </g>
   <g id="patch_13">
    <path d="M 110.74 75123.036752 
L 145.46 75123.036752 
L 145.46 83.246064 
L 110.74 83.246064 
z
" clip-path="url(#p4d30eba118)" style="fill: #e98e83"/>
   </g>
   <g id="patch_14">
    <path d="M 154.14 75123.036752 
L 188.86 75123.036752 
L 188.86 127.836139 
L 154.14 127.836139 
z
" clip-path="url(#p4d30eba118)" style="fill: #e98e83"/>
   </g>
   <g id="patch_15">
    <path d="M 197.54 75123.036752 
L 232.26 75123.036752 
L 232.26 183.634647 
L 197.54 183.634647 
z
" clip-path="url(#p4d30eba118)" style="fill: #e98e83"/>
   </g>
   <g id="patch_16">
    <path d="M 240.94 75123.036752 
L 275.66 75123.036752 
L 275.66 212.086407 
L 240.94 212.086407 
z
" clip-path="url(#p4d30eba118)" style="fill: #e98e83"/>
   </g>
   <g id="patch_17">
    <path d="M 284.34 75123.036752 
L 319.06 75123.036752 
L 319.06 234.872021 
L 284.34 234.872021 
z
" clip-path="url(#p4d30eba118)" style="fill: #e98e83"/>
   </g>
   <g id="patch_18">
    <path d="M 327.74 75123.036752 
L 362.46 75123.036752 
L 362.46 246.24 
L 327.74 246.24 
z
" clip-path="url(#p4d30eba118)" style="fill: #e98e83"/>
   </g>
   <g id="patch_19">
    <path d="M 371.14 75123.036752 
L 405.86 75123.036752 
L 405.86 244.625088 
L 371.14 244.625088 
z
" clip-path="url(#p4d30eba118)" style="fill: #e98e83"/>
   </g>
   <g id="patch_20">
    <path d="M 414.54 75123.036752 
L 449.26 75123.036752 
L 449.26 242.297494 
L 414.54 242.297494 
z
" clip-path="url(#p4d30eba118)" style="fill: #e98e83"/>
   </g>
   <g id="matplotlib.axis_1">
    <g id="xtick_1">
     <g id="line2d_1">
      <defs>
       <path id="m3bbd27d840" d="M 0 0 
L 0 3.5 
" style="stroke: #000000; stroke-width: 0.8"/>
      </defs>
      <g>
       <use xlink:href="#m3bbd27d840" x="84.7" y="256.32" style="stroke: #000000; stroke-width: 0.8"/>
      </g>
     </g>
     <g id="text_1">
      <text style="font-size: 10px; font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Computer Modern Sans Serif', 'Lucida Grande', 'Verdana', 'Geneva', 'Lucid', 'Arial', 'Helvetica', 'Avant Garde', sans-serif; text-anchor: middle" x="84.7" y="270.918437" transform="rotate(-0 84.7 270.918437)">1x1</text>
     </g>
    </g>
    <g id="xtick_2">
     <g id="line2d_2">
      <g>
       <use xlink:href="#m3bbd27d840" x="128.1" y="256.32" style="stroke: #000000; stroke-width: 0.8"/>
      </g>
     </g>
     <g id="text_2">
      <text style="font-size: 10px; font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Computer Modern Sans Serif', 'Lucida Grande', 'Verdana', 'Geneva', 'Lucid', 'Arial', 'Helvetica', 'Avant Garde', sans-serif; text-anchor: middle" x="128.1" y="270.918437" transform="rotate(-0 128.1 270.918437)">2x2</text>
     </g>
    </g>
    <g id="xtick_3">
     <g id="line2d_3">
      <g>
       <use xlink:href="#m3bbd27d840" x="171.5" y="256.32" style="stroke: #000000; stroke-width: 0.8"/>
      </g>
     </g>
     <g id="text_3">
      <text style="font-size: 10px; font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Computer Modern Sans Serif', 'Lucida Grande', 'Verdana', 'Geneva', 'Lucid', 'Arial', 'Helvetica', 'Avant Garde', sans-serif; text-anchor: middle" x="171.5" y="270.918437" transform="rotate(-0 171.5 270.918437)">4x4</text>
     </g>
    </g>
    <g id="xtick_4">
     <g id="line2d_4">
      <g>
       <use xlink:href="#m3bbd27d840" x="214.9" y="256.32" style="stroke: #000000; stroke-width: 0.8"/>
      </g>
     </g>
     <g id="text_4">
      <text style="font-size: 10px; font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Computer Modern Sans Serif', 'Lucida Grande', 'Verdana', 'Geneva', 'Lucid', 'Arial', 'Helvetica', 'Avant Garde', sans-serif; text-anchor: middle" x="214.9" y="270.918437" transform="rotate(-0 214.9 270.918437)">8x8</text>
     </g>
    </g>
    <g id="xtick_5">
     <g id="line2d_5">
      <g>
       <use xlink:href="#m3bbd27d840" x="258.3" y="256.32" style="stroke: #000000; stroke-width: 0.8"/>
      </g>
     </g>
     <g id="text_5">
      <text style="font-size: 10px; font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Computer Modern Sans Serif', 'Lucida Grande', 'Verdana', 'Geneva', 'Lucid', 'Arial', 'Helvetica', 'Avant Garde', sans-serif; text-anchor: middle" x="258.3" y="270.918437" transform="rotate(-0 258.3 270.918437)">16x16</text>
     </g>
    </g>
    <g id="xtick_6">
     <g id="line2d_6">
      <g>
       <use xlink:href="#m3bbd27d840" x="301.7" y="256.32" style="stroke: #000000; stroke-width: 0.8"/>
      </g>
     </g>
     <g id="text_6">
      <text style="font-size: 10px; font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Computer Modern Sans Serif', 'Lucida Grande', 'Verdana', 'Geneva', 'Lucid', 'Arial', 'Helvetica', 'Avant Garde', sans-serif; text-anchor: middle" x="301.7" y="270.918437" transform="rotate(-0 301.7 270.918437)">32x32</text>
     </g>
    </g>
    <g id="xtick_7">
     <g id="line2d_7">
      <g>
       <use xlink:href="#m3bbd27d840" x="345.1" y="256.32" style="stroke: #000000; stroke-width: 0.8"/>
      </g>
     </g>
     <g id="text_7">
      <text style="font-size: 10px; font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Computer Modern Sans Serif', 'Lucida Grande', 'Verdana', 'Geneva', 'Lucid', 'Arial', 'Helvetica', 'Avant Garde', sans-serif; text-anchor: middle" x="345.1" y="270.918437" transform="rotate(-0 345.1 270.918437)">64x64</text>
     </g>
    </g>
    <g id="xtick_8">
     <g id="line2d_8">
      <g>
       <use xlink:href="#m3bbd27d840" x="388.5" y="256.32" style="stroke: #000000; stroke-width: 0.8"/>
      </g>
     </g>
     <g id="text_8">
      <text style="font-size: 10px; font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Computer Modern Sans Serif', 'Lucida Grande', 'Verdana', 'Geneva', 'Lucid', 'Arial', 'Helvetica', 'Avant Garde', sans-serif; text-anchor: middle" x="388.5" y="270.918437" transform="rotate(-0 388.5 270.918437)">128x128</text>
     </g>
    </g>
    <g id="xtick_9">
     <g id="line2d_9">
      <g>
       <use xlink:href="#m3bbd27d840" x="431.9" y="256.32" style="stroke: #000000; stroke-width: 0.8"/>
      </g>
     </g>
     <g id="text_9">
      <text style="font-size: 10px; font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Computer Modern Sans Serif', 'Lucida Grande', 'Verdana', 'Geneva', 'Lucid', 'Arial', 'Helvetica', 'Avant Garde', sans-serif; text-anchor: middle" x="431.9" y="270.918437" transform="rotate(-0 431.9 270.918437)">256x256</text>
     </g>
    </g>
    <g id="text_10">
     <text style="font-size: 10px; font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Computer Modern Sans Serif', 'Lucida Grande', 'Verdana', 'Geneva', 'Lucid', 'Arial', 'Helvetica', 'Avant Garde', sans-serif; text-anchor: middle" x="258.3" y="284.596563" transform="rotate(-0 258.3 284.596563)">Number of chunks</text>
    </g>
   </g>
   <g id="matplotlib.axis_2">
    <g id="ytick_1">
     <g id="line2d_10">
      <defs>
       <path id="m01284ad646" d="M 0 0 
L -3.5 0 
" style="stroke: #000000; stroke-width: 0.8"/>
      </defs>
      <g>
       <use xlink:href="#m01284ad646" x="63" y="226.496228" style="stroke: #000000; stroke-width: 0.8"/>
      </g>
     </g>
     <g id="text_11">
      <!-- $\mathdefault{10^{1}}$ -->
      <g transform="translate(38.4 230.295447)">
       <text>
        <tspan x="0" y="-0.064063" style="font-size: 10px; font-family: 'DejaVu Sans'">1</tspan>
        <tspan x="6.362305" y="-0.064063" style="font-size: 10px; font-family: 'DejaVu Sans'">0</tspan>
        <tspan x="12.820312" y="-3.892188" style="font-size: 7px; font-family: 'DejaVu Sans'">1</tspan>
       </text>
      </g>
     </g>
    </g>
    <g id="ytick_2">
     <g id="line2d_11">
      <g>
       <use xlink:href="#m01284ad646" x="63" y="151.674509" style="stroke: #000000; stroke-width: 0.8"/>
      </g>
     </g>
     <g id="text_12">
      <!-- $\mathdefault{10^{2}}$ -->
      <g transform="translate(38.4 155.473728)">
       <text>
        <tspan x="0" y="-0.976562" style="font-size: 10px; font-family: 'DejaVu Sans'">1</tspan>
        <tspan x="6.362305" y="-0.976562" style="font-size: 10px; font-family: 'DejaVu Sans'">0</tspan>
        <tspan x="12.820312" y="-4.804688" style="font-size: 7px; font-family: 'DejaVu Sans'">2</tspan>
       </text>
      </g>
     </g>
    </g>
    <g id="ytick_3">
     <g id="line2d_12">
      <g>
       <use xlink:href="#m01284ad646" x="63" y="76.852791" style="stroke: #000000; stroke-width: 0.8"/>
      </g>
     </g>
     <g id="text_13">
      <!-- $\mathdefault{10^{3}}$ -->
      <g transform="translate(38.4 80.652009)">
       <text>
        <tspan x="0" y="-0.976562" style="font-size: 10px; font-family: 'DejaVu Sans'">1</tspan>
        <tspan x="6.362305" y="-0.976562" style="font-size: 10px; font-family: 'DejaVu Sans'">0</tspan>
        <tspan x="12.820312" y="-4.804688" style="font-size: 7px; font-family: 'DejaVu Sans'">3</tspan>
       </text>
      </g>
     </g>
    </g>
    <g id="ytick_4">
     <g id="line2d_13">
      <defs>
       <path id="me7966272bd" d="M 0 0 
L -2 0 
" style="stroke: #000000; stroke-width: 0.6"/>
      </defs>
      <g>
       <use xlink:href="#me7966272bd" x="63" y="256.270784" style="stroke: #000000; stroke-width: 0.6"/>
      </g>
     </g>
    </g>
    <g id="ytick_5">
     <g id="line2d_14">
      <g>
       <use xlink:href="#me7966272bd" x="63" y="249.01981" style="stroke: #000000; stroke-width: 0.6"/>
      </g>
     </g>
    </g>
    <g id="ytick_6">
     <g id="line2d_15">
      <g>
       <use xlink:href="#me7966272bd" x="63" y="243.095333" style="stroke: #000000; stroke-width: 0.6"/>
      </g>
     </g>
    </g>
    <g id="ytick_7">
     <g id="line2d_16">
      <g>
       <use xlink:href="#me7966272bd" x="63" y="238.086259" style="stroke: #000000; stroke-width: 0.6"/>
      </g>
     </g>
    </g>
    <g id="ytick_8">
     <g id="line2d_17">
      <g>
       <use xlink:href="#me7966272bd" x="63" y="233.747202" style="stroke: #000000; stroke-width: 0.6"/>
      </g>
     </g>
    </g>
    <g id="ytick_9">
     <g id="line2d_18">
      <g>
       <use xlink:href="#me7966272bd" x="63" y="229.919882" style="stroke: #000000; stroke-width: 0.6"/>
      </g>
     </g>
    </g>
    <g id="ytick_10">
     <g id="line2d_19">
      <g>
       <use xlink:href="#me7966272bd" x="63" y="203.972647" style="stroke: #000000; stroke-width: 0.6"/>
      </g>
     </g>
    </g>
    <g id="ytick_11">
     <g id="line2d_20">
      <g>
       <use xlink:href="#me7966272bd" x="63" y="190.797196" style="stroke: #000000; stroke-width: 0.6"/>
      </g>
     </g>
    </g>
    <g id="ytick_12">
     <g id="line2d_21">
      <g>
       <use xlink:href="#me7966272bd" x="63" y="181.449065" style="stroke: #000000; stroke-width: 0.6"/>
      </g>
     </g>
    </g>
    <g id="ytick_13">
     <g id="line2d_22">
      <g>
       <use xlink:href="#me7966272bd" x="63" y="174.198091" style="stroke: #000000; stroke-width: 0.6"/>
      </g>
     </g>
    </g>
    <g id="ytick_14">
     <g id="line2d_23">
      <g>
       <use xlink:href="#me7966272bd" x="63" y="168.273614" style="stroke: #000000; stroke-width: 0.6"/>
      </g>
     </g>
    </g>
    <g id="ytick_15">
     <g id="line2d_24">
      <g>
       <use xlink:href="#me7966272bd" x="63" y="163.26454" style="stroke: #000000; stroke-width: 0.6"/>
      </g>
     </g>
    </g>
    <g id="ytick_16">
     <g id="line2d_25">
      <g>
       <use xlink:href="#me7966272bd" x="63" y="158.925483" style="stroke: #000000; stroke-width: 0.6"/>
      </g>
     </g>
    </g>
    <g id="ytick_17">
     <g id="line2d_26">
      <g>
       <use xlink:href="#me7966272bd" x="63" y="155.098164" style="stroke: #000000; stroke-width: 0.6"/>
      </g>
     </g>
    </g>
    <g id="ytick_18">
     <g id="line2d_27">
      <g>
       <use xlink:href="#me7966272bd" x="63" y="129.150928" style="stroke: #000000; stroke-width: 0.6"/>
      </g>
     </g>
    </g>
    <g id="ytick_19">
     <g id="line2d_28">
      <g>
       <use xlink:href="#me7966272bd" x="63" y="115.975477" style="stroke: #000000; stroke-width: 0.6"/>
      </g>
     </g>
    </g>
    <g id="ytick_20">
     <g id="line2d_29">
      <g>
       <use xlink:href="#me7966272bd" x="63" y="106.627346" style="stroke: #000000; stroke-width: 0.6"/>
      </g>
     </g>
    </g>
    <g id="ytick_21">
     <g id="line2d_30">
      <g>
       <use xlink:href="#me7966272bd" x="63" y="99.376372" style="stroke: #000000; stroke-width: 0.6"/>
      </g>
     </g>
    </g>
    <g id="ytick_22">
     <g id="line2d_31">
      <g>
       <use xlink:href="#me7966272bd" x="63" y="93.451895" style="stroke: #000000; stroke-width: 0.6"/>
      </g>
     </g>
    </g>
    <g id="ytick_23">
     <g id="line2d_32">
      <g>
       <use xlink:href="#me7966272bd" x="63" y="88.442822" style="stroke: #000000; stroke-width: 0.6"/>
      </g>
     </g>
    </g>
    <g id="ytick_24">
     <g id="line2d_33">
      <g>
       <use xlink:href="#me7966272bd" x="63" y="84.103764" style="stroke: #000000; stroke-width: 0.6"/>
      </g>
     </g>
    </g>
    <g id="ytick_25">
     <g id="line2d_34">
      <g>
       <use xlink:href="#me7966272bd" x="63" y="80.276445" style="stroke: #000000; stroke-width: 0.6"/>
      </g>
     </g>
    </g>
    <g id="ytick_26">
     <g id="line2d_35">
      <g>
       <use xlink:href="#me7966272bd" x="63" y="54.329209" style="stroke: #000000; stroke-width: 0.6"/>
      </g>
     </g>
    </g>
    <g id="ytick_27">
     <g id="line2d_36">
      <g>
       <use xlink:href="#me7966272bd" x="63" y="41.153758" style="stroke: #000000; stroke-width: 0.6"/>
      </g>
     </g>
    </g>
    <g id="text_14">
     <text style="font-size: 10px; font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Computer Modern Sans Serif', 'Lucida Grande', 'Verdana', 'Geneva', 'Lucid', 'Arial', 'Helvetica', 'Avant Garde', sans-serif; text-anchor: middle" x="32.320312" y="145.44" transform="rotate(-90 32.320312 145.44)">Runtime (milliseconds, log scale)</text>
    </g>
   </g>
   <g id="line2d_37">
    <path clip-path="url(#p4d30eba118)" style="fill: none; stroke: #424242; stroke-width: 2.25; stroke-linecap: square"/>
   </g>
   <g id="line2d_38">
    <path clip-path="url(#p4d30eba118)" style="fill: none; stroke: #424242; stroke-width: 2.25; stroke-linecap: square"/>
   </g>
   <g id="line2d_39">
    <path clip-path="url(#p4d30eba118)" style="fill: none; stroke: #424242; stroke-width: 2.25; stroke-linecap: square"/>
   </g>
   <g id="line2d_40">
    <path clip-path="url(#p4d30eba118)" style="fill: none; stroke: #424242; stroke-width: 2.25; stroke-linecap: square"/>
   </g>
   <g id="line2d_41">
    <path clip-path="url(#p4d30eba118)" style="fill: none; stroke: #424242; stroke-width: 2.25; stroke-linecap: square"/>
   </g>
   <g id="line2d_42">
    <path clip-path="url(#p4d30eba118)" style="fill: none; stroke: #424242; stroke-width: 2.25; stroke-linecap: square"/>
   </g>
   <g id="line2d_43">
    <path clip-path="url(#p4d30eba118)" style="fill: none; stroke: #424242; stroke-width: 2.25; stroke-linecap: square"/>
   </g>
   <g id="line2d_44">
    <path clip-path="url(#p4d30eba118)" style="fill: none; stroke: #424242; stroke-width: 2.25; stroke-linecap: square"/>
   </g>
   <g id="line2d_45">
    <path clip-path="url(#p4d30eba118)" style="fill: none; stroke: #424242; stroke-width: 2.25; stroke-linecap: square"/>
   </g>
   <g id="line2d_46">
    <path clip-path="url(#p4d30eba118)" style="fill: none; stroke: #424242; stroke-width: 2.25; stroke-linecap: square"/>
   </g>
   <g id="line2d_47">
    <path clip-path="url(#p4d30eba118)" style="fill: none; stroke: #424242; stroke-width: 2.25; stroke-linecap: square"/>
   </g>
   <g id="line2d_48">
    <path clip-path="url(#p4d30eba118)" style="fill: none; stroke: #424242; stroke-width: 2.25; stroke-linecap: square"/>
   </g>
   <g id="line2d_49">
    <path clip-path="url(#p4d30eba118)" style="fill: none; stroke: #424242; stroke-width: 2.25; stroke-linecap: square"/>
   </g>
   <g id="line2d_50">
    <path clip-path="url(#p4d30eba118)" style="fill: none; stroke: #424242; stroke-width: 2.25; stroke-linecap: square"/>
   </g>
   <g id="line2d_51">
    <path clip-path="url(#p4d30eba118)" style="fill: none; stroke: #424242; stroke-width: 2.25; stroke-linecap: square"/>
   </g>
   <g id="line2d_52">
    <path clip-path="url(#p4d30eba118)" style="fill: none; stroke: #424242; stroke-width: 2.25; stroke-linecap: square"/>
   </g>
   <g id="line2d_53">
    <path clip-path="url(#p4d30eba118)" style="fill: none; stroke: #424242; stroke-width: 2.25; stroke-linecap: square"/>
   </g>
   <g id="line2d_54">
    <path clip-path="url(#p4d30eba118)" style="fill: none; stroke: #424242; stroke-width: 2.25; stroke-linecap: square"/>
   </g>
   <g id="patch_21">
    <path d="M 63 256.32 
L 63 34.56 
" style="fill: none; stroke: #000000; stroke-width: 0.8; stroke-linejoin: miter; stroke-linecap: square"/>
   </g>
   <g id="patch_22">
    <path d="M 453.6 256.32 
L 453.6 34.56 
" style="fill: none; stroke: #000000; stroke-width: 0.8; stroke-linejoin: miter; stroke-linecap: square"/>
   </g>
   <g id="patch_23">
    <path d="M 63 256.32 
L 453.6 256.32 
" style="fill: none; stroke: #000000; stroke-width: 0.8; stroke-linejoin: miter; stroke-linecap: square"/>
   </g>
   <g id="patch_24">
    <path d="M 63 34.56 
L 453.6 34.56 
" style="fill: none; stroke: #000000; stroke-width: 0.8; stroke-linejoin: miter; stroke-linecap: square"/>
   </g>
   <g id="text_15">
    <text style="font-size: 12px; font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Computer Modern Sans Serif', 'Lucida Grande', 'Verdana', 'Geneva', 'Lucid', 'Arial', 'Helvetica', 'Avant Garde', sans-serif; text-anchor: middle" x="258.3" y="28.56" transform="rotate(-0 258.3 28.56)">Overall performance by number of image subdivisions</text>
   </g>
   <g id="legend_1">
    <g id="patch_25">
     <path d="M 328.8 71.91625 
L 446.6 71.91625 
Q 448.6 71.91625 448.6 69.91625 
L 448.6 41.56 
Q 448.6 39.56 446.6 39.56 
L 328.8 39.56 
Q 326.8 39.56 326.8 41.56 
L 326.8 69.91625 
Q 326.8 71.91625 328.8 71.91625 
z
" style="fill: #ffffff; opacity: 0.8; stroke: #cccccc; stroke-linejoin: miter"/>
    </g>
    <g id="patch_26">
     <path d="M 330.8 51.158437 
L 350.8 51.158437 
L 350.8 44.158437 
L 330.8 44.158437 
z
" style="fill: #add8e6; stroke: #add8e6; stroke-linejoin: miter"/>
    </g>
    <g id="text_16">
     <text style="font-size: 10px; font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Computer Modern Sans Serif', 'Lucida Grande', 'Verdana', 'Geneva', 'Lucid', 'Arial', 'Helvetica', 'Avant Garde', sans-serif; text-anchor: start" x="358.8" y="51.158437" transform="rotate(-0 358.8 51.158437)">Compilation time</text>
    </g>
    <g id="patch_27">
     <path d="M 330.8 65.836562 
L 350.8 65.836562 
L 350.8 58.836562 
L 330.8 58.836562 
z
" style="fill: #fa8072; stroke: #fa8072; stroke-linejoin: miter"/>
    </g>
    <g id="text_17">
     <text style="font-size: 10px; font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Computer Modern Sans Serif', 'Lucida Grande', 'Verdana', 'Geneva', 'Lucid', 'Arial', 'Helvetica', 'Avant Garde', sans-serif; text-anchor: start" x="358.8" y="65.836562" transform="rotate(-0 358.8 65.836562)">Evaluation time</text>
    </g>
   </g>
  </g>
 </g>
 <defs>
  <clipPath id="p4d30eba118">
   <rect x="63" y="34.56" width="390.6" height="221.76"/>
  </clipPath>
 </defs>
</svg>

</figure>
<p>Cutting up the image into more chunks does result in better evaluation performance (at least up to 64 subdivisions), but the time taken up by compiling the code for all those chunks quickly starts to outweigh those savings. 16x16 seems like the optimal number of chunks to split the image into, resulting in the overall lowest runtime.</p>
<p>With that, here are our final results, compared to our previous intermediate results:</p>
<div class="table-wrapper">
<table><thead><tr><th>Image size</th><th>Unoptimized</th><th>Optimized (16x16 chunks)</th><th>Speedup</th></tr></thead><tbody>
<tr><td>256</td><td>13.7 ms</td><td>14.6 ms</td><td>0.94x</td></tr>
<tr><td>512</td><td>44.2 ms</td><td>13.6 ms</td><td>3.25x</td></tr>
<tr><td>1024</td><td>162.1 ms</td><td>14.6 ms</td><td>11.10x</td></tr>
<tr><td>2048</td><td>637.6 ms</td><td>17.9 ms</td><td>35.62x</td></tr>
<tr><td>4096</td><td>2.546 s</td><td>31.4 ms</td><td>81.08x</td></tr>
</tbody></table>
</div>
<p>Now these are some impressive numbers if I do say so myself!
We can evaluate a 4K image in less than a thirtieth of a second, meaning we could sustain a framerate of 30fps if we were to use this as an interactive visualizer. Not bad for a CPU-only implementation!</p>
<h2 id="conclusion">Conclusion</h2>
<p>There are a few more optimizations that I glossed over, such as specializing the program by recursively subdividing it into chunks
rather than iteratively, and writing the installed code of different chunks into a single buffer.
Once again, feel free to check out <a href="https://github.com/CRefice/prospero.jit/tree/main/src">the actual source code</a> to see the version of the code I obtained the results with.</p>
<p>Looking at other people's submissions, it seems like I approached this problem somewhat "backwards".
I started off with the idea of writing a compiler, then stumbled upon the idea of optimizing the program by chunks.
Had I discovered the chunking idea first, writing a compiler would probably have been unnecessary in terms of performance.</p>
<p>Still, I learned a ton during this project and had a lot of fun, and I hope you gained something from this as well.</p>


        </main>
        <footer>
    <p class="copyright" xmlns:cc="http://creativecommons.org/ns#">© 2025 Carlo Refice | Licensed under <a href="http://creativecommons.org/licenses/by-sa/4.0/?ref=chooser-v1" target="_blank" rel="license noopener noreferrer" style="display:inline-block;">CC BY-SA 4.0</a></p>
</footer>

    </body>
</html>
